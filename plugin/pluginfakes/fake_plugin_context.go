// Code generated by counterfeiter. DO NOT EDIT.
package pluginfakes

import (
	sync "sync"

	models "github.com/IBM-Cloud/ibm-cloud-cli-sdk/bluemix/models"
	plugin "github.com/IBM-Cloud/ibm-cloud-cli-sdk/plugin"
)

type FakePluginContext struct {
	APIEndpointStub        func() string
	aPIEndpointMutex       sync.RWMutex
	aPIEndpointArgsForCall []struct {
	}
	aPIEndpointReturns struct {
		result1 string
	}
	aPIEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	CFStub        func() plugin.CFContext
	cFMutex       sync.RWMutex
	cFArgsForCall []struct {
	}
	cFReturns struct {
		result1 plugin.CFContext
	}
	cFReturnsOnCall map[int]struct {
		result1 plugin.CFContext
	}
	CFEEEnvIDStub        func() string
	cFEEEnvIDMutex       sync.RWMutex
	cFEEEnvIDArgsForCall []struct {
	}
	cFEEEnvIDReturns struct {
		result1 string
	}
	cFEEEnvIDReturnsOnCall map[int]struct {
		result1 string
	}
	CLINameStub        func() string
	cLINameMutex       sync.RWMutex
	cLINameArgsForCall []struct {
	}
	cLINameReturns struct {
		result1 string
	}
	cLINameReturnsOnCall map[int]struct {
		result1 string
	}
	CloudNameStub        func() string
	cloudNameMutex       sync.RWMutex
	cloudNameArgsForCall []struct {
	}
	cloudNameReturns struct {
		result1 string
	}
	cloudNameReturnsOnCall map[int]struct {
		result1 string
	}
	CloudTypeStub        func() string
	cloudTypeMutex       sync.RWMutex
	cloudTypeArgsForCall []struct {
	}
	cloudTypeReturns struct {
		result1 string
	}
	cloudTypeReturnsOnCall map[int]struct {
		result1 string
	}
	ColorEnabledStub        func() string
	colorEnabledMutex       sync.RWMutex
	colorEnabledArgsForCall []struct {
	}
	colorEnabledReturns struct {
		result1 string
	}
	colorEnabledReturnsOnCall map[int]struct {
		result1 string
	}
	CommandNamespaceStub        func() string
	commandNamespaceMutex       sync.RWMutex
	commandNamespaceArgsForCall []struct {
	}
	commandNamespaceReturns struct {
		result1 string
	}
	commandNamespaceReturnsOnCall map[int]struct {
		result1 string
	}
	ConsoleEndpointStub        func() string
	consoleEndpointMutex       sync.RWMutex
	consoleEndpointArgsForCall []struct {
	}
	consoleEndpointReturns struct {
		result1 string
	}
	consoleEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	CurrentAccountStub        func() models.Account
	currentAccountMutex       sync.RWMutex
	currentAccountArgsForCall []struct {
	}
	currentAccountReturns struct {
		result1 models.Account
	}
	currentAccountReturnsOnCall map[int]struct {
		result1 models.Account
	}
	CurrentRegionStub        func() models.Region
	currentRegionMutex       sync.RWMutex
	currentRegionArgsForCall []struct {
	}
	currentRegionReturns struct {
		result1 models.Region
	}
	currentRegionReturnsOnCall map[int]struct {
		result1 models.Region
	}
	CurrentResourceGroupStub        func() models.ResourceGroup
	currentResourceGroupMutex       sync.RWMutex
	currentResourceGroupArgsForCall []struct {
	}
	currentResourceGroupReturns struct {
		result1 models.ResourceGroup
	}
	currentResourceGroupReturnsOnCall map[int]struct {
		result1 models.ResourceGroup
	}
	HTTPTimeoutStub        func() int
	hTTPTimeoutMutex       sync.RWMutex
	hTTPTimeoutArgsForCall []struct {
	}
	hTTPTimeoutReturns struct {
		result1 int
	}
	hTTPTimeoutReturnsOnCall map[int]struct {
		result1 int
	}
	HasAPIEndpointStub        func() bool
	hasAPIEndpointMutex       sync.RWMutex
	hasAPIEndpointArgsForCall []struct {
	}
	hasAPIEndpointReturns struct {
		result1 bool
	}
	hasAPIEndpointReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedAccountStub        func() bool
	hasTargetedAccountMutex       sync.RWMutex
	hasTargetedAccountArgsForCall []struct {
	}
	hasTargetedAccountReturns struct {
		result1 bool
	}
	hasTargetedAccountReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedCFStub        func() bool
	hasTargetedCFMutex       sync.RWMutex
	hasTargetedCFArgsForCall []struct {
	}
	hasTargetedCFReturns struct {
		result1 bool
	}
	hasTargetedCFReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedCFEEStub        func() bool
	hasTargetedCFEEMutex       sync.RWMutex
	hasTargetedCFEEArgsForCall []struct {
	}
	hasTargetedCFEEReturns struct {
		result1 bool
	}
	hasTargetedCFEEReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedPublicCFStub        func() bool
	hasTargetedPublicCFMutex       sync.RWMutex
	hasTargetedPublicCFArgsForCall []struct {
	}
	hasTargetedPublicCFReturns struct {
		result1 bool
	}
	hasTargetedPublicCFReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedRegionStub        func() bool
	hasTargetedRegionMutex       sync.RWMutex
	hasTargetedRegionArgsForCall []struct {
	}
	hasTargetedRegionReturns struct {
		result1 bool
	}
	hasTargetedRegionReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedResourceGroupStub        func() bool
	hasTargetedResourceGroupMutex       sync.RWMutex
	hasTargetedResourceGroupArgsForCall []struct {
	}
	hasTargetedResourceGroupReturns struct {
		result1 bool
	}
	hasTargetedResourceGroupReturnsOnCall map[int]struct {
		result1 bool
	}
	IAMEndpointStub        func() string
	iAMEndpointMutex       sync.RWMutex
	iAMEndpointArgsForCall []struct {
	}
	iAMEndpointReturns struct {
		result1 string
	}
	iAMEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	IAMRefreshTokenStub        func() string
	iAMRefreshTokenMutex       sync.RWMutex
	iAMRefreshTokenArgsForCall []struct {
	}
	iAMRefreshTokenReturns struct {
		result1 string
	}
	iAMRefreshTokenReturnsOnCall map[int]struct {
		result1 string
	}
	IAMTokenStub        func() string
	iAMTokenMutex       sync.RWMutex
	iAMTokenArgsForCall []struct {
	}
	iAMTokenReturns struct {
		result1 string
	}
	iAMTokenReturnsOnCall map[int]struct {
		result1 string
	}
	IMSAccountIDStub        func() string
	iMSAccountIDMutex       sync.RWMutex
	iMSAccountIDArgsForCall []struct {
	}
	iMSAccountIDReturns struct {
		result1 string
	}
	iMSAccountIDReturnsOnCall map[int]struct {
		result1 string
	}
	IsLoggedInStub        func() bool
	isLoggedInMutex       sync.RWMutex
	isLoggedInArgsForCall []struct {
	}
	isLoggedInReturns struct {
		result1 bool
	}
	isLoggedInReturnsOnCall map[int]struct {
		result1 bool
	}
	IsLoggedInWithServiceIDStub        func() bool
	isLoggedInWithServiceIDMutex       sync.RWMutex
	isLoggedInWithServiceIDArgsForCall []struct {
	}
	isLoggedInWithServiceIDReturns struct {
		result1 bool
	}
	isLoggedInWithServiceIDReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSSLDisabledStub        func() bool
	isSSLDisabledMutex       sync.RWMutex
	isSSLDisabledArgsForCall []struct {
	}
	isSSLDisabledReturns struct {
		result1 bool
	}
	isSSLDisabledReturnsOnCall map[int]struct {
		result1 bool
	}
	LocaleStub        func() string
	localeMutex       sync.RWMutex
	localeArgsForCall []struct {
	}
	localeReturns struct {
		result1 string
	}
	localeReturnsOnCall map[int]struct {
		result1 string
	}
	PluginConfigStub        func() plugin.PluginConfig
	pluginConfigMutex       sync.RWMutex
	pluginConfigArgsForCall []struct {
	}
	pluginConfigReturns struct {
		result1 plugin.PluginConfig
	}
	pluginConfigReturnsOnCall map[int]struct {
		result1 plugin.PluginConfig
	}
	PluginDirectoryStub        func() string
	pluginDirectoryMutex       sync.RWMutex
	pluginDirectoryArgsForCall []struct {
	}
	pluginDirectoryReturns struct {
		result1 string
	}
	pluginDirectoryReturnsOnCall map[int]struct {
		result1 string
	}
	RefreshIAMTokenStub        func() (string, error)
	refreshIAMTokenMutex       sync.RWMutex
	refreshIAMTokenArgsForCall []struct {
	}
	refreshIAMTokenReturns struct {
		result1 string
		result2 error
	}
	refreshIAMTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	TraceStub        func() string
	traceMutex       sync.RWMutex
	traceArgsForCall []struct {
	}
	traceReturns struct {
		result1 string
	}
	traceReturnsOnCall map[int]struct {
		result1 string
	}
	UserEmailStub        func() string
	userEmailMutex       sync.RWMutex
	userEmailArgsForCall []struct {
	}
	userEmailReturns struct {
		result1 string
	}
	userEmailReturnsOnCall map[int]struct {
		result1 string
	}
	VersionCheckEnabledStub        func() bool
	versionCheckEnabledMutex       sync.RWMutex
	versionCheckEnabledArgsForCall []struct {
	}
	versionCheckEnabledReturns struct {
		result1 bool
	}
	versionCheckEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePluginContext) APIEndpoint() string {
	fake.aPIEndpointMutex.Lock()
	ret, specificReturn := fake.aPIEndpointReturnsOnCall[len(fake.aPIEndpointArgsForCall)]
	fake.aPIEndpointArgsForCall = append(fake.aPIEndpointArgsForCall, struct {
	}{})
	fake.recordInvocation("APIEndpoint", []interface{}{})
	fake.aPIEndpointMutex.Unlock()
	if fake.APIEndpointStub != nil {
		return fake.APIEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.aPIEndpointReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) APIEndpointCallCount() int {
	fake.aPIEndpointMutex.RLock()
	defer fake.aPIEndpointMutex.RUnlock()
	return len(fake.aPIEndpointArgsForCall)
}

func (fake *FakePluginContext) APIEndpointCalls(stub func() string) {
	fake.aPIEndpointMutex.Lock()
	defer fake.aPIEndpointMutex.Unlock()
	fake.APIEndpointStub = stub
}

func (fake *FakePluginContext) APIEndpointReturns(result1 string) {
	fake.aPIEndpointMutex.Lock()
	defer fake.aPIEndpointMutex.Unlock()
	fake.APIEndpointStub = nil
	fake.aPIEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) APIEndpointReturnsOnCall(i int, result1 string) {
	fake.aPIEndpointMutex.Lock()
	defer fake.aPIEndpointMutex.Unlock()
	fake.APIEndpointStub = nil
	if fake.aPIEndpointReturnsOnCall == nil {
		fake.aPIEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aPIEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CF() plugin.CFContext {
	fake.cFMutex.Lock()
	ret, specificReturn := fake.cFReturnsOnCall[len(fake.cFArgsForCall)]
	fake.cFArgsForCall = append(fake.cFArgsForCall, struct {
	}{})
	fake.recordInvocation("CF", []interface{}{})
	fake.cFMutex.Unlock()
	if fake.CFStub != nil {
		return fake.CFStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cFReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CFCallCount() int {
	fake.cFMutex.RLock()
	defer fake.cFMutex.RUnlock()
	return len(fake.cFArgsForCall)
}

func (fake *FakePluginContext) CFCalls(stub func() plugin.CFContext) {
	fake.cFMutex.Lock()
	defer fake.cFMutex.Unlock()
	fake.CFStub = stub
}

func (fake *FakePluginContext) CFReturns(result1 plugin.CFContext) {
	fake.cFMutex.Lock()
	defer fake.cFMutex.Unlock()
	fake.CFStub = nil
	fake.cFReturns = struct {
		result1 plugin.CFContext
	}{result1}
}

func (fake *FakePluginContext) CFReturnsOnCall(i int, result1 plugin.CFContext) {
	fake.cFMutex.Lock()
	defer fake.cFMutex.Unlock()
	fake.CFStub = nil
	if fake.cFReturnsOnCall == nil {
		fake.cFReturnsOnCall = make(map[int]struct {
			result1 plugin.CFContext
		})
	}
	fake.cFReturnsOnCall[i] = struct {
		result1 plugin.CFContext
	}{result1}
}

func (fake *FakePluginContext) CFEEEnvID() string {
	fake.cFEEEnvIDMutex.Lock()
	ret, specificReturn := fake.cFEEEnvIDReturnsOnCall[len(fake.cFEEEnvIDArgsForCall)]
	fake.cFEEEnvIDArgsForCall = append(fake.cFEEEnvIDArgsForCall, struct {
	}{})
	fake.recordInvocation("CFEEEnvID", []interface{}{})
	fake.cFEEEnvIDMutex.Unlock()
	if fake.CFEEEnvIDStub != nil {
		return fake.CFEEEnvIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cFEEEnvIDReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CFEEEnvIDCallCount() int {
	fake.cFEEEnvIDMutex.RLock()
	defer fake.cFEEEnvIDMutex.RUnlock()
	return len(fake.cFEEEnvIDArgsForCall)
}

func (fake *FakePluginContext) CFEEEnvIDCalls(stub func() string) {
	fake.cFEEEnvIDMutex.Lock()
	defer fake.cFEEEnvIDMutex.Unlock()
	fake.CFEEEnvIDStub = stub
}

func (fake *FakePluginContext) CFEEEnvIDReturns(result1 string) {
	fake.cFEEEnvIDMutex.Lock()
	defer fake.cFEEEnvIDMutex.Unlock()
	fake.CFEEEnvIDStub = nil
	fake.cFEEEnvIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CFEEEnvIDReturnsOnCall(i int, result1 string) {
	fake.cFEEEnvIDMutex.Lock()
	defer fake.cFEEEnvIDMutex.Unlock()
	fake.CFEEEnvIDStub = nil
	if fake.cFEEEnvIDReturnsOnCall == nil {
		fake.cFEEEnvIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cFEEEnvIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CLIName() string {
	fake.cLINameMutex.Lock()
	ret, specificReturn := fake.cLINameReturnsOnCall[len(fake.cLINameArgsForCall)]
	fake.cLINameArgsForCall = append(fake.cLINameArgsForCall, struct {
	}{})
	fake.recordInvocation("CLIName", []interface{}{})
	fake.cLINameMutex.Unlock()
	if fake.CLINameStub != nil {
		return fake.CLINameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cLINameReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CLINameCallCount() int {
	fake.cLINameMutex.RLock()
	defer fake.cLINameMutex.RUnlock()
	return len(fake.cLINameArgsForCall)
}

func (fake *FakePluginContext) CLINameCalls(stub func() string) {
	fake.cLINameMutex.Lock()
	defer fake.cLINameMutex.Unlock()
	fake.CLINameStub = stub
}

func (fake *FakePluginContext) CLINameReturns(result1 string) {
	fake.cLINameMutex.Lock()
	defer fake.cLINameMutex.Unlock()
	fake.CLINameStub = nil
	fake.cLINameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CLINameReturnsOnCall(i int, result1 string) {
	fake.cLINameMutex.Lock()
	defer fake.cLINameMutex.Unlock()
	fake.CLINameStub = nil
	if fake.cLINameReturnsOnCall == nil {
		fake.cLINameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cLINameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudName() string {
	fake.cloudNameMutex.Lock()
	ret, specificReturn := fake.cloudNameReturnsOnCall[len(fake.cloudNameArgsForCall)]
	fake.cloudNameArgsForCall = append(fake.cloudNameArgsForCall, struct {
	}{})
	fake.recordInvocation("CloudName", []interface{}{})
	fake.cloudNameMutex.Unlock()
	if fake.CloudNameStub != nil {
		return fake.CloudNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cloudNameReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CloudNameCallCount() int {
	fake.cloudNameMutex.RLock()
	defer fake.cloudNameMutex.RUnlock()
	return len(fake.cloudNameArgsForCall)
}

func (fake *FakePluginContext) CloudNameCalls(stub func() string) {
	fake.cloudNameMutex.Lock()
	defer fake.cloudNameMutex.Unlock()
	fake.CloudNameStub = stub
}

func (fake *FakePluginContext) CloudNameReturns(result1 string) {
	fake.cloudNameMutex.Lock()
	defer fake.cloudNameMutex.Unlock()
	fake.CloudNameStub = nil
	fake.cloudNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudNameReturnsOnCall(i int, result1 string) {
	fake.cloudNameMutex.Lock()
	defer fake.cloudNameMutex.Unlock()
	fake.CloudNameStub = nil
	if fake.cloudNameReturnsOnCall == nil {
		fake.cloudNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cloudNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudType() string {
	fake.cloudTypeMutex.Lock()
	ret, specificReturn := fake.cloudTypeReturnsOnCall[len(fake.cloudTypeArgsForCall)]
	fake.cloudTypeArgsForCall = append(fake.cloudTypeArgsForCall, struct {
	}{})
	fake.recordInvocation("CloudType", []interface{}{})
	fake.cloudTypeMutex.Unlock()
	if fake.CloudTypeStub != nil {
		return fake.CloudTypeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cloudTypeReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CloudTypeCallCount() int {
	fake.cloudTypeMutex.RLock()
	defer fake.cloudTypeMutex.RUnlock()
	return len(fake.cloudTypeArgsForCall)
}

func (fake *FakePluginContext) CloudTypeCalls(stub func() string) {
	fake.cloudTypeMutex.Lock()
	defer fake.cloudTypeMutex.Unlock()
	fake.CloudTypeStub = stub
}

func (fake *FakePluginContext) CloudTypeReturns(result1 string) {
	fake.cloudTypeMutex.Lock()
	defer fake.cloudTypeMutex.Unlock()
	fake.CloudTypeStub = nil
	fake.cloudTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudTypeReturnsOnCall(i int, result1 string) {
	fake.cloudTypeMutex.Lock()
	defer fake.cloudTypeMutex.Unlock()
	fake.CloudTypeStub = nil
	if fake.cloudTypeReturnsOnCall == nil {
		fake.cloudTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cloudTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ColorEnabled() string {
	fake.colorEnabledMutex.Lock()
	ret, specificReturn := fake.colorEnabledReturnsOnCall[len(fake.colorEnabledArgsForCall)]
	fake.colorEnabledArgsForCall = append(fake.colorEnabledArgsForCall, struct {
	}{})
	fake.recordInvocation("ColorEnabled", []interface{}{})
	fake.colorEnabledMutex.Unlock()
	if fake.ColorEnabledStub != nil {
		return fake.ColorEnabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.colorEnabledReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) ColorEnabledCallCount() int {
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	return len(fake.colorEnabledArgsForCall)
}

func (fake *FakePluginContext) ColorEnabledCalls(stub func() string) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = stub
}

func (fake *FakePluginContext) ColorEnabledReturns(result1 string) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = nil
	fake.colorEnabledReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ColorEnabledReturnsOnCall(i int, result1 string) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = nil
	if fake.colorEnabledReturnsOnCall == nil {
		fake.colorEnabledReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.colorEnabledReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CommandNamespace() string {
	fake.commandNamespaceMutex.Lock()
	ret, specificReturn := fake.commandNamespaceReturnsOnCall[len(fake.commandNamespaceArgsForCall)]
	fake.commandNamespaceArgsForCall = append(fake.commandNamespaceArgsForCall, struct {
	}{})
	fake.recordInvocation("CommandNamespace", []interface{}{})
	fake.commandNamespaceMutex.Unlock()
	if fake.CommandNamespaceStub != nil {
		return fake.CommandNamespaceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.commandNamespaceReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CommandNamespaceCallCount() int {
	fake.commandNamespaceMutex.RLock()
	defer fake.commandNamespaceMutex.RUnlock()
	return len(fake.commandNamespaceArgsForCall)
}

func (fake *FakePluginContext) CommandNamespaceCalls(stub func() string) {
	fake.commandNamespaceMutex.Lock()
	defer fake.commandNamespaceMutex.Unlock()
	fake.CommandNamespaceStub = stub
}

func (fake *FakePluginContext) CommandNamespaceReturns(result1 string) {
	fake.commandNamespaceMutex.Lock()
	defer fake.commandNamespaceMutex.Unlock()
	fake.CommandNamespaceStub = nil
	fake.commandNamespaceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CommandNamespaceReturnsOnCall(i int, result1 string) {
	fake.commandNamespaceMutex.Lock()
	defer fake.commandNamespaceMutex.Unlock()
	fake.CommandNamespaceStub = nil
	if fake.commandNamespaceReturnsOnCall == nil {
		fake.commandNamespaceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.commandNamespaceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpoint() string {
	fake.consoleEndpointMutex.Lock()
	ret, specificReturn := fake.consoleEndpointReturnsOnCall[len(fake.consoleEndpointArgsForCall)]
	fake.consoleEndpointArgsForCall = append(fake.consoleEndpointArgsForCall, struct {
	}{})
	fake.recordInvocation("ConsoleEndpoint", []interface{}{})
	fake.consoleEndpointMutex.Unlock()
	if fake.ConsoleEndpointStub != nil {
		return fake.ConsoleEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.consoleEndpointReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) ConsoleEndpointCallCount() int {
	fake.consoleEndpointMutex.RLock()
	defer fake.consoleEndpointMutex.RUnlock()
	return len(fake.consoleEndpointArgsForCall)
}

func (fake *FakePluginContext) ConsoleEndpointCalls(stub func() string) {
	fake.consoleEndpointMutex.Lock()
	defer fake.consoleEndpointMutex.Unlock()
	fake.ConsoleEndpointStub = stub
}

func (fake *FakePluginContext) ConsoleEndpointReturns(result1 string) {
	fake.consoleEndpointMutex.Lock()
	defer fake.consoleEndpointMutex.Unlock()
	fake.ConsoleEndpointStub = nil
	fake.consoleEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpointReturnsOnCall(i int, result1 string) {
	fake.consoleEndpointMutex.Lock()
	defer fake.consoleEndpointMutex.Unlock()
	fake.ConsoleEndpointStub = nil
	if fake.consoleEndpointReturnsOnCall == nil {
		fake.consoleEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.consoleEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CurrentAccount() models.Account {
	fake.currentAccountMutex.Lock()
	ret, specificReturn := fake.currentAccountReturnsOnCall[len(fake.currentAccountArgsForCall)]
	fake.currentAccountArgsForCall = append(fake.currentAccountArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentAccount", []interface{}{})
	fake.currentAccountMutex.Unlock()
	if fake.CurrentAccountStub != nil {
		return fake.CurrentAccountStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.currentAccountReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentAccountCallCount() int {
	fake.currentAccountMutex.RLock()
	defer fake.currentAccountMutex.RUnlock()
	return len(fake.currentAccountArgsForCall)
}

func (fake *FakePluginContext) CurrentAccountCalls(stub func() models.Account) {
	fake.currentAccountMutex.Lock()
	defer fake.currentAccountMutex.Unlock()
	fake.CurrentAccountStub = stub
}

func (fake *FakePluginContext) CurrentAccountReturns(result1 models.Account) {
	fake.currentAccountMutex.Lock()
	defer fake.currentAccountMutex.Unlock()
	fake.CurrentAccountStub = nil
	fake.currentAccountReturns = struct {
		result1 models.Account
	}{result1}
}

func (fake *FakePluginContext) CurrentAccountReturnsOnCall(i int, result1 models.Account) {
	fake.currentAccountMutex.Lock()
	defer fake.currentAccountMutex.Unlock()
	fake.CurrentAccountStub = nil
	if fake.currentAccountReturnsOnCall == nil {
		fake.currentAccountReturnsOnCall = make(map[int]struct {
			result1 models.Account
		})
	}
	fake.currentAccountReturnsOnCall[i] = struct {
		result1 models.Account
	}{result1}
}

func (fake *FakePluginContext) CurrentRegion() models.Region {
	fake.currentRegionMutex.Lock()
	ret, specificReturn := fake.currentRegionReturnsOnCall[len(fake.currentRegionArgsForCall)]
	fake.currentRegionArgsForCall = append(fake.currentRegionArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentRegion", []interface{}{})
	fake.currentRegionMutex.Unlock()
	if fake.CurrentRegionStub != nil {
		return fake.CurrentRegionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.currentRegionReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentRegionCallCount() int {
	fake.currentRegionMutex.RLock()
	defer fake.currentRegionMutex.RUnlock()
	return len(fake.currentRegionArgsForCall)
}

func (fake *FakePluginContext) CurrentRegionCalls(stub func() models.Region) {
	fake.currentRegionMutex.Lock()
	defer fake.currentRegionMutex.Unlock()
	fake.CurrentRegionStub = stub
}

func (fake *FakePluginContext) CurrentRegionReturns(result1 models.Region) {
	fake.currentRegionMutex.Lock()
	defer fake.currentRegionMutex.Unlock()
	fake.CurrentRegionStub = nil
	fake.currentRegionReturns = struct {
		result1 models.Region
	}{result1}
}

func (fake *FakePluginContext) CurrentRegionReturnsOnCall(i int, result1 models.Region) {
	fake.currentRegionMutex.Lock()
	defer fake.currentRegionMutex.Unlock()
	fake.CurrentRegionStub = nil
	if fake.currentRegionReturnsOnCall == nil {
		fake.currentRegionReturnsOnCall = make(map[int]struct {
			result1 models.Region
		})
	}
	fake.currentRegionReturnsOnCall[i] = struct {
		result1 models.Region
	}{result1}
}

func (fake *FakePluginContext) CurrentResourceGroup() models.ResourceGroup {
	fake.currentResourceGroupMutex.Lock()
	ret, specificReturn := fake.currentResourceGroupReturnsOnCall[len(fake.currentResourceGroupArgsForCall)]
	fake.currentResourceGroupArgsForCall = append(fake.currentResourceGroupArgsForCall, struct {
	}{})
	fake.recordInvocation("CurrentResourceGroup", []interface{}{})
	fake.currentResourceGroupMutex.Unlock()
	if fake.CurrentResourceGroupStub != nil {
		return fake.CurrentResourceGroupStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.currentResourceGroupReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentResourceGroupCallCount() int {
	fake.currentResourceGroupMutex.RLock()
	defer fake.currentResourceGroupMutex.RUnlock()
	return len(fake.currentResourceGroupArgsForCall)
}

func (fake *FakePluginContext) CurrentResourceGroupCalls(stub func() models.ResourceGroup) {
	fake.currentResourceGroupMutex.Lock()
	defer fake.currentResourceGroupMutex.Unlock()
	fake.CurrentResourceGroupStub = stub
}

func (fake *FakePluginContext) CurrentResourceGroupReturns(result1 models.ResourceGroup) {
	fake.currentResourceGroupMutex.Lock()
	defer fake.currentResourceGroupMutex.Unlock()
	fake.CurrentResourceGroupStub = nil
	fake.currentResourceGroupReturns = struct {
		result1 models.ResourceGroup
	}{result1}
}

func (fake *FakePluginContext) CurrentResourceGroupReturnsOnCall(i int, result1 models.ResourceGroup) {
	fake.currentResourceGroupMutex.Lock()
	defer fake.currentResourceGroupMutex.Unlock()
	fake.CurrentResourceGroupStub = nil
	if fake.currentResourceGroupReturnsOnCall == nil {
		fake.currentResourceGroupReturnsOnCall = make(map[int]struct {
			result1 models.ResourceGroup
		})
	}
	fake.currentResourceGroupReturnsOnCall[i] = struct {
		result1 models.ResourceGroup
	}{result1}
}

func (fake *FakePluginContext) HTTPTimeout() int {
	fake.hTTPTimeoutMutex.Lock()
	ret, specificReturn := fake.hTTPTimeoutReturnsOnCall[len(fake.hTTPTimeoutArgsForCall)]
	fake.hTTPTimeoutArgsForCall = append(fake.hTTPTimeoutArgsForCall, struct {
	}{})
	fake.recordInvocation("HTTPTimeout", []interface{}{})
	fake.hTTPTimeoutMutex.Unlock()
	if fake.HTTPTimeoutStub != nil {
		return fake.HTTPTimeoutStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hTTPTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HTTPTimeoutCallCount() int {
	fake.hTTPTimeoutMutex.RLock()
	defer fake.hTTPTimeoutMutex.RUnlock()
	return len(fake.hTTPTimeoutArgsForCall)
}

func (fake *FakePluginContext) HTTPTimeoutCalls(stub func() int) {
	fake.hTTPTimeoutMutex.Lock()
	defer fake.hTTPTimeoutMutex.Unlock()
	fake.HTTPTimeoutStub = stub
}

func (fake *FakePluginContext) HTTPTimeoutReturns(result1 int) {
	fake.hTTPTimeoutMutex.Lock()
	defer fake.hTTPTimeoutMutex.Unlock()
	fake.HTTPTimeoutStub = nil
	fake.hTTPTimeoutReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePluginContext) HTTPTimeoutReturnsOnCall(i int, result1 int) {
	fake.hTTPTimeoutMutex.Lock()
	defer fake.hTTPTimeoutMutex.Unlock()
	fake.HTTPTimeoutStub = nil
	if fake.hTTPTimeoutReturnsOnCall == nil {
		fake.hTTPTimeoutReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.hTTPTimeoutReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePluginContext) HasAPIEndpoint() bool {
	fake.hasAPIEndpointMutex.Lock()
	ret, specificReturn := fake.hasAPIEndpointReturnsOnCall[len(fake.hasAPIEndpointArgsForCall)]
	fake.hasAPIEndpointArgsForCall = append(fake.hasAPIEndpointArgsForCall, struct {
	}{})
	fake.recordInvocation("HasAPIEndpoint", []interface{}{})
	fake.hasAPIEndpointMutex.Unlock()
	if fake.HasAPIEndpointStub != nil {
		return fake.HasAPIEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasAPIEndpointReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasAPIEndpointCallCount() int {
	fake.hasAPIEndpointMutex.RLock()
	defer fake.hasAPIEndpointMutex.RUnlock()
	return len(fake.hasAPIEndpointArgsForCall)
}

func (fake *FakePluginContext) HasAPIEndpointCalls(stub func() bool) {
	fake.hasAPIEndpointMutex.Lock()
	defer fake.hasAPIEndpointMutex.Unlock()
	fake.HasAPIEndpointStub = stub
}

func (fake *FakePluginContext) HasAPIEndpointReturns(result1 bool) {
	fake.hasAPIEndpointMutex.Lock()
	defer fake.hasAPIEndpointMutex.Unlock()
	fake.HasAPIEndpointStub = nil
	fake.hasAPIEndpointReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasAPIEndpointReturnsOnCall(i int, result1 bool) {
	fake.hasAPIEndpointMutex.Lock()
	defer fake.hasAPIEndpointMutex.Unlock()
	fake.HasAPIEndpointStub = nil
	if fake.hasAPIEndpointReturnsOnCall == nil {
		fake.hasAPIEndpointReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasAPIEndpointReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedAccount() bool {
	fake.hasTargetedAccountMutex.Lock()
	ret, specificReturn := fake.hasTargetedAccountReturnsOnCall[len(fake.hasTargetedAccountArgsForCall)]
	fake.hasTargetedAccountArgsForCall = append(fake.hasTargetedAccountArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedAccount", []interface{}{})
	fake.hasTargetedAccountMutex.Unlock()
	if fake.HasTargetedAccountStub != nil {
		return fake.HasTargetedAccountStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedAccountReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedAccountCallCount() int {
	fake.hasTargetedAccountMutex.RLock()
	defer fake.hasTargetedAccountMutex.RUnlock()
	return len(fake.hasTargetedAccountArgsForCall)
}

func (fake *FakePluginContext) HasTargetedAccountCalls(stub func() bool) {
	fake.hasTargetedAccountMutex.Lock()
	defer fake.hasTargetedAccountMutex.Unlock()
	fake.HasTargetedAccountStub = stub
}

func (fake *FakePluginContext) HasTargetedAccountReturns(result1 bool) {
	fake.hasTargetedAccountMutex.Lock()
	defer fake.hasTargetedAccountMutex.Unlock()
	fake.HasTargetedAccountStub = nil
	fake.hasTargetedAccountReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedAccountReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedAccountMutex.Lock()
	defer fake.hasTargetedAccountMutex.Unlock()
	fake.HasTargetedAccountStub = nil
	if fake.hasTargetedAccountReturnsOnCall == nil {
		fake.hasTargetedAccountReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedAccountReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCF() bool {
	fake.hasTargetedCFMutex.Lock()
	ret, specificReturn := fake.hasTargetedCFReturnsOnCall[len(fake.hasTargetedCFArgsForCall)]
	fake.hasTargetedCFArgsForCall = append(fake.hasTargetedCFArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedCF", []interface{}{})
	fake.hasTargetedCFMutex.Unlock()
	if fake.HasTargetedCFStub != nil {
		return fake.HasTargetedCFStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedCFReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedCFCallCount() int {
	fake.hasTargetedCFMutex.RLock()
	defer fake.hasTargetedCFMutex.RUnlock()
	return len(fake.hasTargetedCFArgsForCall)
}

func (fake *FakePluginContext) HasTargetedCFCalls(stub func() bool) {
	fake.hasTargetedCFMutex.Lock()
	defer fake.hasTargetedCFMutex.Unlock()
	fake.HasTargetedCFStub = stub
}

func (fake *FakePluginContext) HasTargetedCFReturns(result1 bool) {
	fake.hasTargetedCFMutex.Lock()
	defer fake.hasTargetedCFMutex.Unlock()
	fake.HasTargetedCFStub = nil
	fake.hasTargetedCFReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCFReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedCFMutex.Lock()
	defer fake.hasTargetedCFMutex.Unlock()
	fake.HasTargetedCFStub = nil
	if fake.hasTargetedCFReturnsOnCall == nil {
		fake.hasTargetedCFReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedCFReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCFEE() bool {
	fake.hasTargetedCFEEMutex.Lock()
	ret, specificReturn := fake.hasTargetedCFEEReturnsOnCall[len(fake.hasTargetedCFEEArgsForCall)]
	fake.hasTargetedCFEEArgsForCall = append(fake.hasTargetedCFEEArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedCFEE", []interface{}{})
	fake.hasTargetedCFEEMutex.Unlock()
	if fake.HasTargetedCFEEStub != nil {
		return fake.HasTargetedCFEEStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedCFEEReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedCFEECallCount() int {
	fake.hasTargetedCFEEMutex.RLock()
	defer fake.hasTargetedCFEEMutex.RUnlock()
	return len(fake.hasTargetedCFEEArgsForCall)
}

func (fake *FakePluginContext) HasTargetedCFEECalls(stub func() bool) {
	fake.hasTargetedCFEEMutex.Lock()
	defer fake.hasTargetedCFEEMutex.Unlock()
	fake.HasTargetedCFEEStub = stub
}

func (fake *FakePluginContext) HasTargetedCFEEReturns(result1 bool) {
	fake.hasTargetedCFEEMutex.Lock()
	defer fake.hasTargetedCFEEMutex.Unlock()
	fake.HasTargetedCFEEStub = nil
	fake.hasTargetedCFEEReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCFEEReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedCFEEMutex.Lock()
	defer fake.hasTargetedCFEEMutex.Unlock()
	fake.HasTargetedCFEEStub = nil
	if fake.hasTargetedCFEEReturnsOnCall == nil {
		fake.hasTargetedCFEEReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedCFEEReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedPublicCF() bool {
	fake.hasTargetedPublicCFMutex.Lock()
	ret, specificReturn := fake.hasTargetedPublicCFReturnsOnCall[len(fake.hasTargetedPublicCFArgsForCall)]
	fake.hasTargetedPublicCFArgsForCall = append(fake.hasTargetedPublicCFArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedPublicCF", []interface{}{})
	fake.hasTargetedPublicCFMutex.Unlock()
	if fake.HasTargetedPublicCFStub != nil {
		return fake.HasTargetedPublicCFStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedPublicCFReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedPublicCFCallCount() int {
	fake.hasTargetedPublicCFMutex.RLock()
	defer fake.hasTargetedPublicCFMutex.RUnlock()
	return len(fake.hasTargetedPublicCFArgsForCall)
}

func (fake *FakePluginContext) HasTargetedPublicCFCalls(stub func() bool) {
	fake.hasTargetedPublicCFMutex.Lock()
	defer fake.hasTargetedPublicCFMutex.Unlock()
	fake.HasTargetedPublicCFStub = stub
}

func (fake *FakePluginContext) HasTargetedPublicCFReturns(result1 bool) {
	fake.hasTargetedPublicCFMutex.Lock()
	defer fake.hasTargetedPublicCFMutex.Unlock()
	fake.HasTargetedPublicCFStub = nil
	fake.hasTargetedPublicCFReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedPublicCFReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedPublicCFMutex.Lock()
	defer fake.hasTargetedPublicCFMutex.Unlock()
	fake.HasTargetedPublicCFStub = nil
	if fake.hasTargetedPublicCFReturnsOnCall == nil {
		fake.hasTargetedPublicCFReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedPublicCFReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedRegion() bool {
	fake.hasTargetedRegionMutex.Lock()
	ret, specificReturn := fake.hasTargetedRegionReturnsOnCall[len(fake.hasTargetedRegionArgsForCall)]
	fake.hasTargetedRegionArgsForCall = append(fake.hasTargetedRegionArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedRegion", []interface{}{})
	fake.hasTargetedRegionMutex.Unlock()
	if fake.HasTargetedRegionStub != nil {
		return fake.HasTargetedRegionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedRegionReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedRegionCallCount() int {
	fake.hasTargetedRegionMutex.RLock()
	defer fake.hasTargetedRegionMutex.RUnlock()
	return len(fake.hasTargetedRegionArgsForCall)
}

func (fake *FakePluginContext) HasTargetedRegionCalls(stub func() bool) {
	fake.hasTargetedRegionMutex.Lock()
	defer fake.hasTargetedRegionMutex.Unlock()
	fake.HasTargetedRegionStub = stub
}

func (fake *FakePluginContext) HasTargetedRegionReturns(result1 bool) {
	fake.hasTargetedRegionMutex.Lock()
	defer fake.hasTargetedRegionMutex.Unlock()
	fake.HasTargetedRegionStub = nil
	fake.hasTargetedRegionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedRegionReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedRegionMutex.Lock()
	defer fake.hasTargetedRegionMutex.Unlock()
	fake.HasTargetedRegionStub = nil
	if fake.hasTargetedRegionReturnsOnCall == nil {
		fake.hasTargetedRegionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedRegionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedResourceGroup() bool {
	fake.hasTargetedResourceGroupMutex.Lock()
	ret, specificReturn := fake.hasTargetedResourceGroupReturnsOnCall[len(fake.hasTargetedResourceGroupArgsForCall)]
	fake.hasTargetedResourceGroupArgsForCall = append(fake.hasTargetedResourceGroupArgsForCall, struct {
	}{})
	fake.recordInvocation("HasTargetedResourceGroup", []interface{}{})
	fake.hasTargetedResourceGroupMutex.Unlock()
	if fake.HasTargetedResourceGroupStub != nil {
		return fake.HasTargetedResourceGroupStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hasTargetedResourceGroupReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedResourceGroupCallCount() int {
	fake.hasTargetedResourceGroupMutex.RLock()
	defer fake.hasTargetedResourceGroupMutex.RUnlock()
	return len(fake.hasTargetedResourceGroupArgsForCall)
}

func (fake *FakePluginContext) HasTargetedResourceGroupCalls(stub func() bool) {
	fake.hasTargetedResourceGroupMutex.Lock()
	defer fake.hasTargetedResourceGroupMutex.Unlock()
	fake.HasTargetedResourceGroupStub = stub
}

func (fake *FakePluginContext) HasTargetedResourceGroupReturns(result1 bool) {
	fake.hasTargetedResourceGroupMutex.Lock()
	defer fake.hasTargetedResourceGroupMutex.Unlock()
	fake.HasTargetedResourceGroupStub = nil
	fake.hasTargetedResourceGroupReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedResourceGroupReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedResourceGroupMutex.Lock()
	defer fake.hasTargetedResourceGroupMutex.Unlock()
	fake.HasTargetedResourceGroupStub = nil
	if fake.hasTargetedResourceGroupReturnsOnCall == nil {
		fake.hasTargetedResourceGroupReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedResourceGroupReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IAMEndpoint() string {
	fake.iAMEndpointMutex.Lock()
	ret, specificReturn := fake.iAMEndpointReturnsOnCall[len(fake.iAMEndpointArgsForCall)]
	fake.iAMEndpointArgsForCall = append(fake.iAMEndpointArgsForCall, struct {
	}{})
	fake.recordInvocation("IAMEndpoint", []interface{}{})
	fake.iAMEndpointMutex.Unlock()
	if fake.IAMEndpointStub != nil {
		return fake.IAMEndpointStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iAMEndpointReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMEndpointCallCount() int {
	fake.iAMEndpointMutex.RLock()
	defer fake.iAMEndpointMutex.RUnlock()
	return len(fake.iAMEndpointArgsForCall)
}

func (fake *FakePluginContext) IAMEndpointCalls(stub func() string) {
	fake.iAMEndpointMutex.Lock()
	defer fake.iAMEndpointMutex.Unlock()
	fake.IAMEndpointStub = stub
}

func (fake *FakePluginContext) IAMEndpointReturns(result1 string) {
	fake.iAMEndpointMutex.Lock()
	defer fake.iAMEndpointMutex.Unlock()
	fake.IAMEndpointStub = nil
	fake.iAMEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMEndpointReturnsOnCall(i int, result1 string) {
	fake.iAMEndpointMutex.Lock()
	defer fake.iAMEndpointMutex.Unlock()
	fake.IAMEndpointStub = nil
	if fake.iAMEndpointReturnsOnCall == nil {
		fake.iAMEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMRefreshToken() string {
	fake.iAMRefreshTokenMutex.Lock()
	ret, specificReturn := fake.iAMRefreshTokenReturnsOnCall[len(fake.iAMRefreshTokenArgsForCall)]
	fake.iAMRefreshTokenArgsForCall = append(fake.iAMRefreshTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("IAMRefreshToken", []interface{}{})
	fake.iAMRefreshTokenMutex.Unlock()
	if fake.IAMRefreshTokenStub != nil {
		return fake.IAMRefreshTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iAMRefreshTokenReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMRefreshTokenCallCount() int {
	fake.iAMRefreshTokenMutex.RLock()
	defer fake.iAMRefreshTokenMutex.RUnlock()
	return len(fake.iAMRefreshTokenArgsForCall)
}

func (fake *FakePluginContext) IAMRefreshTokenCalls(stub func() string) {
	fake.iAMRefreshTokenMutex.Lock()
	defer fake.iAMRefreshTokenMutex.Unlock()
	fake.IAMRefreshTokenStub = stub
}

func (fake *FakePluginContext) IAMRefreshTokenReturns(result1 string) {
	fake.iAMRefreshTokenMutex.Lock()
	defer fake.iAMRefreshTokenMutex.Unlock()
	fake.IAMRefreshTokenStub = nil
	fake.iAMRefreshTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMRefreshTokenReturnsOnCall(i int, result1 string) {
	fake.iAMRefreshTokenMutex.Lock()
	defer fake.iAMRefreshTokenMutex.Unlock()
	fake.IAMRefreshTokenStub = nil
	if fake.iAMRefreshTokenReturnsOnCall == nil {
		fake.iAMRefreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMRefreshTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMToken() string {
	fake.iAMTokenMutex.Lock()
	ret, specificReturn := fake.iAMTokenReturnsOnCall[len(fake.iAMTokenArgsForCall)]
	fake.iAMTokenArgsForCall = append(fake.iAMTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("IAMToken", []interface{}{})
	fake.iAMTokenMutex.Unlock()
	if fake.IAMTokenStub != nil {
		return fake.IAMTokenStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iAMTokenReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMTokenCallCount() int {
	fake.iAMTokenMutex.RLock()
	defer fake.iAMTokenMutex.RUnlock()
	return len(fake.iAMTokenArgsForCall)
}

func (fake *FakePluginContext) IAMTokenCalls(stub func() string) {
	fake.iAMTokenMutex.Lock()
	defer fake.iAMTokenMutex.Unlock()
	fake.IAMTokenStub = stub
}

func (fake *FakePluginContext) IAMTokenReturns(result1 string) {
	fake.iAMTokenMutex.Lock()
	defer fake.iAMTokenMutex.Unlock()
	fake.IAMTokenStub = nil
	fake.iAMTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMTokenReturnsOnCall(i int, result1 string) {
	fake.iAMTokenMutex.Lock()
	defer fake.iAMTokenMutex.Unlock()
	fake.IAMTokenStub = nil
	if fake.iAMTokenReturnsOnCall == nil {
		fake.iAMTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IMSAccountID() string {
	fake.iMSAccountIDMutex.Lock()
	ret, specificReturn := fake.iMSAccountIDReturnsOnCall[len(fake.iMSAccountIDArgsForCall)]
	fake.iMSAccountIDArgsForCall = append(fake.iMSAccountIDArgsForCall, struct {
	}{})
	fake.recordInvocation("IMSAccountID", []interface{}{})
	fake.iMSAccountIDMutex.Unlock()
	if fake.IMSAccountIDStub != nil {
		return fake.IMSAccountIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iMSAccountIDReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IMSAccountIDCallCount() int {
	fake.iMSAccountIDMutex.RLock()
	defer fake.iMSAccountIDMutex.RUnlock()
	return len(fake.iMSAccountIDArgsForCall)
}

func (fake *FakePluginContext) IMSAccountIDCalls(stub func() string) {
	fake.iMSAccountIDMutex.Lock()
	defer fake.iMSAccountIDMutex.Unlock()
	fake.IMSAccountIDStub = stub
}

func (fake *FakePluginContext) IMSAccountIDReturns(result1 string) {
	fake.iMSAccountIDMutex.Lock()
	defer fake.iMSAccountIDMutex.Unlock()
	fake.IMSAccountIDStub = nil
	fake.iMSAccountIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IMSAccountIDReturnsOnCall(i int, result1 string) {
	fake.iMSAccountIDMutex.Lock()
	defer fake.iMSAccountIDMutex.Unlock()
	fake.IMSAccountIDStub = nil
	if fake.iMSAccountIDReturnsOnCall == nil {
		fake.iMSAccountIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iMSAccountIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IsLoggedIn() bool {
	fake.isLoggedInMutex.Lock()
	ret, specificReturn := fake.isLoggedInReturnsOnCall[len(fake.isLoggedInArgsForCall)]
	fake.isLoggedInArgsForCall = append(fake.isLoggedInArgsForCall, struct {
	}{})
	fake.recordInvocation("IsLoggedIn", []interface{}{})
	fake.isLoggedInMutex.Unlock()
	if fake.IsLoggedInStub != nil {
		return fake.IsLoggedInStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isLoggedInReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsLoggedInCallCount() int {
	fake.isLoggedInMutex.RLock()
	defer fake.isLoggedInMutex.RUnlock()
	return len(fake.isLoggedInArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInCalls(stub func() bool) {
	fake.isLoggedInMutex.Lock()
	defer fake.isLoggedInMutex.Unlock()
	fake.IsLoggedInStub = stub
}

func (fake *FakePluginContext) IsLoggedInReturns(result1 bool) {
	fake.isLoggedInMutex.Lock()
	defer fake.isLoggedInMutex.Unlock()
	fake.IsLoggedInStub = nil
	fake.isLoggedInReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInReturnsOnCall(i int, result1 bool) {
	fake.isLoggedInMutex.Lock()
	defer fake.isLoggedInMutex.Unlock()
	fake.IsLoggedInStub = nil
	if fake.isLoggedInReturnsOnCall == nil {
		fake.isLoggedInReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInWithServiceID() bool {
	fake.isLoggedInWithServiceIDMutex.Lock()
	ret, specificReturn := fake.isLoggedInWithServiceIDReturnsOnCall[len(fake.isLoggedInWithServiceIDArgsForCall)]
	fake.isLoggedInWithServiceIDArgsForCall = append(fake.isLoggedInWithServiceIDArgsForCall, struct {
	}{})
	fake.recordInvocation("IsLoggedInWithServiceID", []interface{}{})
	fake.isLoggedInWithServiceIDMutex.Unlock()
	if fake.IsLoggedInWithServiceIDStub != nil {
		return fake.IsLoggedInWithServiceIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isLoggedInWithServiceIDReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDCallCount() int {
	fake.isLoggedInWithServiceIDMutex.RLock()
	defer fake.isLoggedInWithServiceIDMutex.RUnlock()
	return len(fake.isLoggedInWithServiceIDArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDCalls(stub func() bool) {
	fake.isLoggedInWithServiceIDMutex.Lock()
	defer fake.isLoggedInWithServiceIDMutex.Unlock()
	fake.IsLoggedInWithServiceIDStub = stub
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDReturns(result1 bool) {
	fake.isLoggedInWithServiceIDMutex.Lock()
	defer fake.isLoggedInWithServiceIDMutex.Unlock()
	fake.IsLoggedInWithServiceIDStub = nil
	fake.isLoggedInWithServiceIDReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDReturnsOnCall(i int, result1 bool) {
	fake.isLoggedInWithServiceIDMutex.Lock()
	defer fake.isLoggedInWithServiceIDMutex.Unlock()
	fake.IsLoggedInWithServiceIDStub = nil
	if fake.isLoggedInWithServiceIDReturnsOnCall == nil {
		fake.isLoggedInWithServiceIDReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInWithServiceIDReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsSSLDisabled() bool {
	fake.isSSLDisabledMutex.Lock()
	ret, specificReturn := fake.isSSLDisabledReturnsOnCall[len(fake.isSSLDisabledArgsForCall)]
	fake.isSSLDisabledArgsForCall = append(fake.isSSLDisabledArgsForCall, struct {
	}{})
	fake.recordInvocation("IsSSLDisabled", []interface{}{})
	fake.isSSLDisabledMutex.Unlock()
	if fake.IsSSLDisabledStub != nil {
		return fake.IsSSLDisabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isSSLDisabledReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsSSLDisabledCallCount() int {
	fake.isSSLDisabledMutex.RLock()
	defer fake.isSSLDisabledMutex.RUnlock()
	return len(fake.isSSLDisabledArgsForCall)
}

func (fake *FakePluginContext) IsSSLDisabledCalls(stub func() bool) {
	fake.isSSLDisabledMutex.Lock()
	defer fake.isSSLDisabledMutex.Unlock()
	fake.IsSSLDisabledStub = stub
}

func (fake *FakePluginContext) IsSSLDisabledReturns(result1 bool) {
	fake.isSSLDisabledMutex.Lock()
	defer fake.isSSLDisabledMutex.Unlock()
	fake.IsSSLDisabledStub = nil
	fake.isSSLDisabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsSSLDisabledReturnsOnCall(i int, result1 bool) {
	fake.isSSLDisabledMutex.Lock()
	defer fake.isSSLDisabledMutex.Unlock()
	fake.IsSSLDisabledStub = nil
	if fake.isSSLDisabledReturnsOnCall == nil {
		fake.isSSLDisabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSSLDisabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) Locale() string {
	fake.localeMutex.Lock()
	ret, specificReturn := fake.localeReturnsOnCall[len(fake.localeArgsForCall)]
	fake.localeArgsForCall = append(fake.localeArgsForCall, struct {
	}{})
	fake.recordInvocation("Locale", []interface{}{})
	fake.localeMutex.Unlock()
	if fake.LocaleStub != nil {
		return fake.LocaleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.localeReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) LocaleCallCount() int {
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	return len(fake.localeArgsForCall)
}

func (fake *FakePluginContext) LocaleCalls(stub func() string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = stub
}

func (fake *FakePluginContext) LocaleReturns(result1 string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = nil
	fake.localeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) LocaleReturnsOnCall(i int, result1 string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = nil
	if fake.localeReturnsOnCall == nil {
		fake.localeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) PluginConfig() plugin.PluginConfig {
	fake.pluginConfigMutex.Lock()
	ret, specificReturn := fake.pluginConfigReturnsOnCall[len(fake.pluginConfigArgsForCall)]
	fake.pluginConfigArgsForCall = append(fake.pluginConfigArgsForCall, struct {
	}{})
	fake.recordInvocation("PluginConfig", []interface{}{})
	fake.pluginConfigMutex.Unlock()
	if fake.PluginConfigStub != nil {
		return fake.PluginConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginConfigReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) PluginConfigCallCount() int {
	fake.pluginConfigMutex.RLock()
	defer fake.pluginConfigMutex.RUnlock()
	return len(fake.pluginConfigArgsForCall)
}

func (fake *FakePluginContext) PluginConfigCalls(stub func() plugin.PluginConfig) {
	fake.pluginConfigMutex.Lock()
	defer fake.pluginConfigMutex.Unlock()
	fake.PluginConfigStub = stub
}

func (fake *FakePluginContext) PluginConfigReturns(result1 plugin.PluginConfig) {
	fake.pluginConfigMutex.Lock()
	defer fake.pluginConfigMutex.Unlock()
	fake.PluginConfigStub = nil
	fake.pluginConfigReturns = struct {
		result1 plugin.PluginConfig
	}{result1}
}

func (fake *FakePluginContext) PluginConfigReturnsOnCall(i int, result1 plugin.PluginConfig) {
	fake.pluginConfigMutex.Lock()
	defer fake.pluginConfigMutex.Unlock()
	fake.PluginConfigStub = nil
	if fake.pluginConfigReturnsOnCall == nil {
		fake.pluginConfigReturnsOnCall = make(map[int]struct {
			result1 plugin.PluginConfig
		})
	}
	fake.pluginConfigReturnsOnCall[i] = struct {
		result1 plugin.PluginConfig
	}{result1}
}

func (fake *FakePluginContext) PluginDirectory() string {
	fake.pluginDirectoryMutex.Lock()
	ret, specificReturn := fake.pluginDirectoryReturnsOnCall[len(fake.pluginDirectoryArgsForCall)]
	fake.pluginDirectoryArgsForCall = append(fake.pluginDirectoryArgsForCall, struct {
	}{})
	fake.recordInvocation("PluginDirectory", []interface{}{})
	fake.pluginDirectoryMutex.Unlock()
	if fake.PluginDirectoryStub != nil {
		return fake.PluginDirectoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pluginDirectoryReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) PluginDirectoryCallCount() int {
	fake.pluginDirectoryMutex.RLock()
	defer fake.pluginDirectoryMutex.RUnlock()
	return len(fake.pluginDirectoryArgsForCall)
}

func (fake *FakePluginContext) PluginDirectoryCalls(stub func() string) {
	fake.pluginDirectoryMutex.Lock()
	defer fake.pluginDirectoryMutex.Unlock()
	fake.PluginDirectoryStub = stub
}

func (fake *FakePluginContext) PluginDirectoryReturns(result1 string) {
	fake.pluginDirectoryMutex.Lock()
	defer fake.pluginDirectoryMutex.Unlock()
	fake.PluginDirectoryStub = nil
	fake.pluginDirectoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) PluginDirectoryReturnsOnCall(i int, result1 string) {
	fake.pluginDirectoryMutex.Lock()
	defer fake.pluginDirectoryMutex.Unlock()
	fake.PluginDirectoryStub = nil
	if fake.pluginDirectoryReturnsOnCall == nil {
		fake.pluginDirectoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pluginDirectoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RefreshIAMToken() (string, error) {
	fake.refreshIAMTokenMutex.Lock()
	ret, specificReturn := fake.refreshIAMTokenReturnsOnCall[len(fake.refreshIAMTokenArgsForCall)]
	fake.refreshIAMTokenArgsForCall = append(fake.refreshIAMTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("RefreshIAMToken", []interface{}{})
	fake.refreshIAMTokenMutex.Unlock()
	if fake.RefreshIAMTokenStub != nil {
		return fake.RefreshIAMTokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.refreshIAMTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginContext) RefreshIAMTokenCallCount() int {
	fake.refreshIAMTokenMutex.RLock()
	defer fake.refreshIAMTokenMutex.RUnlock()
	return len(fake.refreshIAMTokenArgsForCall)
}

func (fake *FakePluginContext) RefreshIAMTokenCalls(stub func() (string, error)) {
	fake.refreshIAMTokenMutex.Lock()
	defer fake.refreshIAMTokenMutex.Unlock()
	fake.RefreshIAMTokenStub = stub
}

func (fake *FakePluginContext) RefreshIAMTokenReturns(result1 string, result2 error) {
	fake.refreshIAMTokenMutex.Lock()
	defer fake.refreshIAMTokenMutex.Unlock()
	fake.RefreshIAMTokenStub = nil
	fake.refreshIAMTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) RefreshIAMTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.refreshIAMTokenMutex.Lock()
	defer fake.refreshIAMTokenMutex.Unlock()
	fake.RefreshIAMTokenStub = nil
	if fake.refreshIAMTokenReturnsOnCall == nil {
		fake.refreshIAMTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.refreshIAMTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) Trace() string {
	fake.traceMutex.Lock()
	ret, specificReturn := fake.traceReturnsOnCall[len(fake.traceArgsForCall)]
	fake.traceArgsForCall = append(fake.traceArgsForCall, struct {
	}{})
	fake.recordInvocation("Trace", []interface{}{})
	fake.traceMutex.Unlock()
	if fake.TraceStub != nil {
		return fake.TraceStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.traceReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) TraceCallCount() int {
	fake.traceMutex.RLock()
	defer fake.traceMutex.RUnlock()
	return len(fake.traceArgsForCall)
}

func (fake *FakePluginContext) TraceCalls(stub func() string) {
	fake.traceMutex.Lock()
	defer fake.traceMutex.Unlock()
	fake.TraceStub = stub
}

func (fake *FakePluginContext) TraceReturns(result1 string) {
	fake.traceMutex.Lock()
	defer fake.traceMutex.Unlock()
	fake.TraceStub = nil
	fake.traceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) TraceReturnsOnCall(i int, result1 string) {
	fake.traceMutex.Lock()
	defer fake.traceMutex.Unlock()
	fake.TraceStub = nil
	if fake.traceReturnsOnCall == nil {
		fake.traceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.traceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserEmail() string {
	fake.userEmailMutex.Lock()
	ret, specificReturn := fake.userEmailReturnsOnCall[len(fake.userEmailArgsForCall)]
	fake.userEmailArgsForCall = append(fake.userEmailArgsForCall, struct {
	}{})
	fake.recordInvocation("UserEmail", []interface{}{})
	fake.userEmailMutex.Unlock()
	if fake.UserEmailStub != nil {
		return fake.UserEmailStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.userEmailReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) UserEmailCallCount() int {
	fake.userEmailMutex.RLock()
	defer fake.userEmailMutex.RUnlock()
	return len(fake.userEmailArgsForCall)
}

func (fake *FakePluginContext) UserEmailCalls(stub func() string) {
	fake.userEmailMutex.Lock()
	defer fake.userEmailMutex.Unlock()
	fake.UserEmailStub = stub
}

func (fake *FakePluginContext) UserEmailReturns(result1 string) {
	fake.userEmailMutex.Lock()
	defer fake.userEmailMutex.Unlock()
	fake.UserEmailStub = nil
	fake.userEmailReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserEmailReturnsOnCall(i int, result1 string) {
	fake.userEmailMutex.Lock()
	defer fake.userEmailMutex.Unlock()
	fake.UserEmailStub = nil
	if fake.userEmailReturnsOnCall == nil {
		fake.userEmailReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userEmailReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) VersionCheckEnabled() bool {
	fake.versionCheckEnabledMutex.Lock()
	ret, specificReturn := fake.versionCheckEnabledReturnsOnCall[len(fake.versionCheckEnabledArgsForCall)]
	fake.versionCheckEnabledArgsForCall = append(fake.versionCheckEnabledArgsForCall, struct {
	}{})
	fake.recordInvocation("VersionCheckEnabled", []interface{}{})
	fake.versionCheckEnabledMutex.Unlock()
	if fake.VersionCheckEnabledStub != nil {
		return fake.VersionCheckEnabledStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.versionCheckEnabledReturns
	return fakeReturns.result1
}

func (fake *FakePluginContext) VersionCheckEnabledCallCount() int {
	fake.versionCheckEnabledMutex.RLock()
	defer fake.versionCheckEnabledMutex.RUnlock()
	return len(fake.versionCheckEnabledArgsForCall)
}

func (fake *FakePluginContext) VersionCheckEnabledCalls(stub func() bool) {
	fake.versionCheckEnabledMutex.Lock()
	defer fake.versionCheckEnabledMutex.Unlock()
	fake.VersionCheckEnabledStub = stub
}

func (fake *FakePluginContext) VersionCheckEnabledReturns(result1 bool) {
	fake.versionCheckEnabledMutex.Lock()
	defer fake.versionCheckEnabledMutex.Unlock()
	fake.VersionCheckEnabledStub = nil
	fake.versionCheckEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) VersionCheckEnabledReturnsOnCall(i int, result1 bool) {
	fake.versionCheckEnabledMutex.Lock()
	defer fake.versionCheckEnabledMutex.Unlock()
	fake.VersionCheckEnabledStub = nil
	if fake.versionCheckEnabledReturnsOnCall == nil {
		fake.versionCheckEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.versionCheckEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aPIEndpointMutex.RLock()
	defer fake.aPIEndpointMutex.RUnlock()
	fake.cFMutex.RLock()
	defer fake.cFMutex.RUnlock()
	fake.cFEEEnvIDMutex.RLock()
	defer fake.cFEEEnvIDMutex.RUnlock()
	fake.cLINameMutex.RLock()
	defer fake.cLINameMutex.RUnlock()
	fake.cloudNameMutex.RLock()
	defer fake.cloudNameMutex.RUnlock()
	fake.cloudTypeMutex.RLock()
	defer fake.cloudTypeMutex.RUnlock()
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	fake.commandNamespaceMutex.RLock()
	defer fake.commandNamespaceMutex.RUnlock()
	fake.consoleEndpointMutex.RLock()
	defer fake.consoleEndpointMutex.RUnlock()
	fake.currentAccountMutex.RLock()
	defer fake.currentAccountMutex.RUnlock()
	fake.currentRegionMutex.RLock()
	defer fake.currentRegionMutex.RUnlock()
	fake.currentResourceGroupMutex.RLock()
	defer fake.currentResourceGroupMutex.RUnlock()
	fake.hTTPTimeoutMutex.RLock()
	defer fake.hTTPTimeoutMutex.RUnlock()
	fake.hasAPIEndpointMutex.RLock()
	defer fake.hasAPIEndpointMutex.RUnlock()
	fake.hasTargetedAccountMutex.RLock()
	defer fake.hasTargetedAccountMutex.RUnlock()
	fake.hasTargetedCFMutex.RLock()
	defer fake.hasTargetedCFMutex.RUnlock()
	fake.hasTargetedCFEEMutex.RLock()
	defer fake.hasTargetedCFEEMutex.RUnlock()
	fake.hasTargetedPublicCFMutex.RLock()
	defer fake.hasTargetedPublicCFMutex.RUnlock()
	fake.hasTargetedRegionMutex.RLock()
	defer fake.hasTargetedRegionMutex.RUnlock()
	fake.hasTargetedResourceGroupMutex.RLock()
	defer fake.hasTargetedResourceGroupMutex.RUnlock()
	fake.iAMEndpointMutex.RLock()
	defer fake.iAMEndpointMutex.RUnlock()
	fake.iAMRefreshTokenMutex.RLock()
	defer fake.iAMRefreshTokenMutex.RUnlock()
	fake.iAMTokenMutex.RLock()
	defer fake.iAMTokenMutex.RUnlock()
	fake.iMSAccountIDMutex.RLock()
	defer fake.iMSAccountIDMutex.RUnlock()
	fake.isLoggedInMutex.RLock()
	defer fake.isLoggedInMutex.RUnlock()
	fake.isLoggedInWithServiceIDMutex.RLock()
	defer fake.isLoggedInWithServiceIDMutex.RUnlock()
	fake.isSSLDisabledMutex.RLock()
	defer fake.isSSLDisabledMutex.RUnlock()
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	fake.pluginConfigMutex.RLock()
	defer fake.pluginConfigMutex.RUnlock()
	fake.pluginDirectoryMutex.RLock()
	defer fake.pluginDirectoryMutex.RUnlock()
	fake.refreshIAMTokenMutex.RLock()
	defer fake.refreshIAMTokenMutex.RUnlock()
	fake.traceMutex.RLock()
	defer fake.traceMutex.RUnlock()
	fake.userEmailMutex.RLock()
	defer fake.userEmailMutex.RUnlock()
	fake.versionCheckEnabledMutex.RLock()
	defer fake.versionCheckEnabledMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePluginContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ plugin.PluginContext = new(FakePluginContext)
