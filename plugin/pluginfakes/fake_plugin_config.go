// Code generated by counterfeiter. DO NOT EDIT.
package pluginfakes

import (
	"sync"

	"github.com/IBM-Cloud/ibm-cloud-cli-sdk/plugin"
)

type FakePluginConfig struct {
	EraseStub        func(string) error
	eraseMutex       sync.RWMutex
	eraseArgsForCall []struct {
		arg1 string
	}
	eraseReturns struct {
		result1 error
	}
	eraseReturnsOnCall map[int]struct {
		result1 error
	}
	ExistsStub        func(string) bool
	existsMutex       sync.RWMutex
	existsArgsForCall []struct {
		arg1 string
	}
	existsReturns struct {
		result1 bool
	}
	existsReturnsOnCall map[int]struct {
		result1 bool
	}
	GetStub        func(string) interface{}
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
	}
	getReturns struct {
		result1 interface{}
	}
	getReturnsOnCall map[int]struct {
		result1 interface{}
	}
	GetBoolStub        func(string) (bool, error)
	getBoolMutex       sync.RWMutex
	getBoolArgsForCall []struct {
		arg1 string
	}
	getBoolReturns struct {
		result1 bool
		result2 error
	}
	getBoolReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetBoolWithDefaultStub        func(string, bool) (bool, error)
	getBoolWithDefaultMutex       sync.RWMutex
	getBoolWithDefaultArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	getBoolWithDefaultReturns struct {
		result1 bool
		result2 error
	}
	getBoolWithDefaultReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetFloatStub        func(string) (float64, error)
	getFloatMutex       sync.RWMutex
	getFloatArgsForCall []struct {
		arg1 string
	}
	getFloatReturns struct {
		result1 float64
		result2 error
	}
	getFloatReturnsOnCall map[int]struct {
		result1 float64
		result2 error
	}
	GetFloatSliceStub        func(string) ([]float64, error)
	getFloatSliceMutex       sync.RWMutex
	getFloatSliceArgsForCall []struct {
		arg1 string
	}
	getFloatSliceReturns struct {
		result1 []float64
		result2 error
	}
	getFloatSliceReturnsOnCall map[int]struct {
		result1 []float64
		result2 error
	}
	GetFloatWithDefaultStub        func(string, float64) (float64, error)
	getFloatWithDefaultMutex       sync.RWMutex
	getFloatWithDefaultArgsForCall []struct {
		arg1 string
		arg2 float64
	}
	getFloatWithDefaultReturns struct {
		result1 float64
		result2 error
	}
	getFloatWithDefaultReturnsOnCall map[int]struct {
		result1 float64
		result2 error
	}
	GetIntStub        func(string) (int, error)
	getIntMutex       sync.RWMutex
	getIntArgsForCall []struct {
		arg1 string
	}
	getIntReturns struct {
		result1 int
		result2 error
	}
	getIntReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetIntSliceStub        func(string) ([]int, error)
	getIntSliceMutex       sync.RWMutex
	getIntSliceArgsForCall []struct {
		arg1 string
	}
	getIntSliceReturns struct {
		result1 []int
		result2 error
	}
	getIntSliceReturnsOnCall map[int]struct {
		result1 []int
		result2 error
	}
	GetIntWithDefaultStub        func(string, int) (int, error)
	getIntWithDefaultMutex       sync.RWMutex
	getIntWithDefaultArgsForCall []struct {
		arg1 string
		arg2 int
	}
	getIntWithDefaultReturns struct {
		result1 int
		result2 error
	}
	getIntWithDefaultReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetStringStub        func(string) (string, error)
	getStringMutex       sync.RWMutex
	getStringArgsForCall []struct {
		arg1 string
	}
	getStringReturns struct {
		result1 string
		result2 error
	}
	getStringReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetStringMapStub        func(string) (map[string]interface{}, error)
	getStringMapMutex       sync.RWMutex
	getStringMapArgsForCall []struct {
		arg1 string
	}
	getStringMapReturns struct {
		result1 map[string]interface{}
		result2 error
	}
	getStringMapReturnsOnCall map[int]struct {
		result1 map[string]interface{}
		result2 error
	}
	GetStringMapStringStub        func(string) (map[string]string, error)
	getStringMapStringMutex       sync.RWMutex
	getStringMapStringArgsForCall []struct {
		arg1 string
	}
	getStringMapStringReturns struct {
		result1 map[string]string
		result2 error
	}
	getStringMapStringReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	GetStringSliceStub        func(string) ([]string, error)
	getStringSliceMutex       sync.RWMutex
	getStringSliceArgsForCall []struct {
		arg1 string
	}
	getStringSliceReturns struct {
		result1 []string
		result2 error
	}
	getStringSliceReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetStringWithDefaultStub        func(string, string) (string, error)
	getStringWithDefaultMutex       sync.RWMutex
	getStringWithDefaultArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getStringWithDefaultReturns struct {
		result1 string
		result2 error
	}
	getStringWithDefaultReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetWithDefaultStub        func(string, interface{}) interface{}
	getWithDefaultMutex       sync.RWMutex
	getWithDefaultArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	getWithDefaultReturns struct {
		result1 interface{}
	}
	getWithDefaultReturnsOnCall map[int]struct {
		result1 interface{}
	}
	SetStub        func(string, interface{}) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	setReturns struct {
		result1 error
	}
	setReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePluginConfig) Erase(arg1 string) error {
	fake.eraseMutex.Lock()
	ret, specificReturn := fake.eraseReturnsOnCall[len(fake.eraseArgsForCall)]
	fake.eraseArgsForCall = append(fake.eraseArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EraseStub
	fakeReturns := fake.eraseReturns
	fake.recordInvocation("Erase", []interface{}{arg1})
	fake.eraseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginConfig) EraseCallCount() int {
	fake.eraseMutex.RLock()
	defer fake.eraseMutex.RUnlock()
	return len(fake.eraseArgsForCall)
}

func (fake *FakePluginConfig) EraseCalls(stub func(string) error) {
	fake.eraseMutex.Lock()
	defer fake.eraseMutex.Unlock()
	fake.EraseStub = stub
}

func (fake *FakePluginConfig) EraseArgsForCall(i int) string {
	fake.eraseMutex.RLock()
	defer fake.eraseMutex.RUnlock()
	argsForCall := fake.eraseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) EraseReturns(result1 error) {
	fake.eraseMutex.Lock()
	defer fake.eraseMutex.Unlock()
	fake.EraseStub = nil
	fake.eraseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) EraseReturnsOnCall(i int, result1 error) {
	fake.eraseMutex.Lock()
	defer fake.eraseMutex.Unlock()
	fake.EraseStub = nil
	if fake.eraseReturnsOnCall == nil {
		fake.eraseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.eraseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) Exists(arg1 string) bool {
	fake.existsMutex.Lock()
	ret, specificReturn := fake.existsReturnsOnCall[len(fake.existsArgsForCall)]
	fake.existsArgsForCall = append(fake.existsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ExistsStub
	fakeReturns := fake.existsReturns
	fake.recordInvocation("Exists", []interface{}{arg1})
	fake.existsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginConfig) ExistsCallCount() int {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	return len(fake.existsArgsForCall)
}

func (fake *FakePluginConfig) ExistsCalls(stub func(string) bool) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = stub
}

func (fake *FakePluginConfig) ExistsArgsForCall(i int) string {
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	argsForCall := fake.existsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) ExistsReturns(result1 bool) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	fake.existsReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginConfig) ExistsReturnsOnCall(i int, result1 bool) {
	fake.existsMutex.Lock()
	defer fake.existsMutex.Unlock()
	fake.ExistsStub = nil
	if fake.existsReturnsOnCall == nil {
		fake.existsReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.existsReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginConfig) Get(arg1 string) interface{} {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginConfig) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakePluginConfig) GetCalls(stub func(string) interface{}) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakePluginConfig) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetReturns(result1 interface{}) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetReturnsOnCall(i int, result1 interface{}) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetBool(arg1 string) (bool, error) {
	fake.getBoolMutex.Lock()
	ret, specificReturn := fake.getBoolReturnsOnCall[len(fake.getBoolArgsForCall)]
	fake.getBoolArgsForCall = append(fake.getBoolArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetBoolStub
	fakeReturns := fake.getBoolReturns
	fake.recordInvocation("GetBool", []interface{}{arg1})
	fake.getBoolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetBoolCallCount() int {
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	return len(fake.getBoolArgsForCall)
}

func (fake *FakePluginConfig) GetBoolCalls(stub func(string) (bool, error)) {
	fake.getBoolMutex.Lock()
	defer fake.getBoolMutex.Unlock()
	fake.GetBoolStub = stub
}

func (fake *FakePluginConfig) GetBoolArgsForCall(i int) string {
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	argsForCall := fake.getBoolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetBoolReturns(result1 bool, result2 error) {
	fake.getBoolMutex.Lock()
	defer fake.getBoolMutex.Unlock()
	fake.GetBoolStub = nil
	fake.getBoolReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBoolReturnsOnCall(i int, result1 bool, result2 error) {
	fake.getBoolMutex.Lock()
	defer fake.getBoolMutex.Unlock()
	fake.GetBoolStub = nil
	if fake.getBoolReturnsOnCall == nil {
		fake.getBoolReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.getBoolReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBoolWithDefault(arg1 string, arg2 bool) (bool, error) {
	fake.getBoolWithDefaultMutex.Lock()
	ret, specificReturn := fake.getBoolWithDefaultReturnsOnCall[len(fake.getBoolWithDefaultArgsForCall)]
	fake.getBoolWithDefaultArgsForCall = append(fake.getBoolWithDefaultArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.GetBoolWithDefaultStub
	fakeReturns := fake.getBoolWithDefaultReturns
	fake.recordInvocation("GetBoolWithDefault", []interface{}{arg1, arg2})
	fake.getBoolWithDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetBoolWithDefaultCallCount() int {
	fake.getBoolWithDefaultMutex.RLock()
	defer fake.getBoolWithDefaultMutex.RUnlock()
	return len(fake.getBoolWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetBoolWithDefaultCalls(stub func(string, bool) (bool, error)) {
	fake.getBoolWithDefaultMutex.Lock()
	defer fake.getBoolWithDefaultMutex.Unlock()
	fake.GetBoolWithDefaultStub = stub
}

func (fake *FakePluginConfig) GetBoolWithDefaultArgsForCall(i int) (string, bool) {
	fake.getBoolWithDefaultMutex.RLock()
	defer fake.getBoolWithDefaultMutex.RUnlock()
	argsForCall := fake.getBoolWithDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfig) GetBoolWithDefaultReturns(result1 bool, result2 error) {
	fake.getBoolWithDefaultMutex.Lock()
	defer fake.getBoolWithDefaultMutex.Unlock()
	fake.GetBoolWithDefaultStub = nil
	fake.getBoolWithDefaultReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetBoolWithDefaultReturnsOnCall(i int, result1 bool, result2 error) {
	fake.getBoolWithDefaultMutex.Lock()
	defer fake.getBoolWithDefaultMutex.Unlock()
	fake.GetBoolWithDefaultStub = nil
	if fake.getBoolWithDefaultReturnsOnCall == nil {
		fake.getBoolWithDefaultReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.getBoolWithDefaultReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloat(arg1 string) (float64, error) {
	fake.getFloatMutex.Lock()
	ret, specificReturn := fake.getFloatReturnsOnCall[len(fake.getFloatArgsForCall)]
	fake.getFloatArgsForCall = append(fake.getFloatArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFloatStub
	fakeReturns := fake.getFloatReturns
	fake.recordInvocation("GetFloat", []interface{}{arg1})
	fake.getFloatMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetFloatCallCount() int {
	fake.getFloatMutex.RLock()
	defer fake.getFloatMutex.RUnlock()
	return len(fake.getFloatArgsForCall)
}

func (fake *FakePluginConfig) GetFloatCalls(stub func(string) (float64, error)) {
	fake.getFloatMutex.Lock()
	defer fake.getFloatMutex.Unlock()
	fake.GetFloatStub = stub
}

func (fake *FakePluginConfig) GetFloatArgsForCall(i int) string {
	fake.getFloatMutex.RLock()
	defer fake.getFloatMutex.RUnlock()
	argsForCall := fake.getFloatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetFloatReturns(result1 float64, result2 error) {
	fake.getFloatMutex.Lock()
	defer fake.getFloatMutex.Unlock()
	fake.GetFloatStub = nil
	fake.getFloatReturns = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatReturnsOnCall(i int, result1 float64, result2 error) {
	fake.getFloatMutex.Lock()
	defer fake.getFloatMutex.Unlock()
	fake.GetFloatStub = nil
	if fake.getFloatReturnsOnCall == nil {
		fake.getFloatReturnsOnCall = make(map[int]struct {
			result1 float64
			result2 error
		})
	}
	fake.getFloatReturnsOnCall[i] = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatSlice(arg1 string) ([]float64, error) {
	fake.getFloatSliceMutex.Lock()
	ret, specificReturn := fake.getFloatSliceReturnsOnCall[len(fake.getFloatSliceArgsForCall)]
	fake.getFloatSliceArgsForCall = append(fake.getFloatSliceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFloatSliceStub
	fakeReturns := fake.getFloatSliceReturns
	fake.recordInvocation("GetFloatSlice", []interface{}{arg1})
	fake.getFloatSliceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetFloatSliceCallCount() int {
	fake.getFloatSliceMutex.RLock()
	defer fake.getFloatSliceMutex.RUnlock()
	return len(fake.getFloatSliceArgsForCall)
}

func (fake *FakePluginConfig) GetFloatSliceCalls(stub func(string) ([]float64, error)) {
	fake.getFloatSliceMutex.Lock()
	defer fake.getFloatSliceMutex.Unlock()
	fake.GetFloatSliceStub = stub
}

func (fake *FakePluginConfig) GetFloatSliceArgsForCall(i int) string {
	fake.getFloatSliceMutex.RLock()
	defer fake.getFloatSliceMutex.RUnlock()
	argsForCall := fake.getFloatSliceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetFloatSliceReturns(result1 []float64, result2 error) {
	fake.getFloatSliceMutex.Lock()
	defer fake.getFloatSliceMutex.Unlock()
	fake.GetFloatSliceStub = nil
	fake.getFloatSliceReturns = struct {
		result1 []float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatSliceReturnsOnCall(i int, result1 []float64, result2 error) {
	fake.getFloatSliceMutex.Lock()
	defer fake.getFloatSliceMutex.Unlock()
	fake.GetFloatSliceStub = nil
	if fake.getFloatSliceReturnsOnCall == nil {
		fake.getFloatSliceReturnsOnCall = make(map[int]struct {
			result1 []float64
			result2 error
		})
	}
	fake.getFloatSliceReturnsOnCall[i] = struct {
		result1 []float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatWithDefault(arg1 string, arg2 float64) (float64, error) {
	fake.getFloatWithDefaultMutex.Lock()
	ret, specificReturn := fake.getFloatWithDefaultReturnsOnCall[len(fake.getFloatWithDefaultArgsForCall)]
	fake.getFloatWithDefaultArgsForCall = append(fake.getFloatWithDefaultArgsForCall, struct {
		arg1 string
		arg2 float64
	}{arg1, arg2})
	stub := fake.GetFloatWithDefaultStub
	fakeReturns := fake.getFloatWithDefaultReturns
	fake.recordInvocation("GetFloatWithDefault", []interface{}{arg1, arg2})
	fake.getFloatWithDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetFloatWithDefaultCallCount() int {
	fake.getFloatWithDefaultMutex.RLock()
	defer fake.getFloatWithDefaultMutex.RUnlock()
	return len(fake.getFloatWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetFloatWithDefaultCalls(stub func(string, float64) (float64, error)) {
	fake.getFloatWithDefaultMutex.Lock()
	defer fake.getFloatWithDefaultMutex.Unlock()
	fake.GetFloatWithDefaultStub = stub
}

func (fake *FakePluginConfig) GetFloatWithDefaultArgsForCall(i int) (string, float64) {
	fake.getFloatWithDefaultMutex.RLock()
	defer fake.getFloatWithDefaultMutex.RUnlock()
	argsForCall := fake.getFloatWithDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfig) GetFloatWithDefaultReturns(result1 float64, result2 error) {
	fake.getFloatWithDefaultMutex.Lock()
	defer fake.getFloatWithDefaultMutex.Unlock()
	fake.GetFloatWithDefaultStub = nil
	fake.getFloatWithDefaultReturns = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetFloatWithDefaultReturnsOnCall(i int, result1 float64, result2 error) {
	fake.getFloatWithDefaultMutex.Lock()
	defer fake.getFloatWithDefaultMutex.Unlock()
	fake.GetFloatWithDefaultStub = nil
	if fake.getFloatWithDefaultReturnsOnCall == nil {
		fake.getFloatWithDefaultReturnsOnCall = make(map[int]struct {
			result1 float64
			result2 error
		})
	}
	fake.getFloatWithDefaultReturnsOnCall[i] = struct {
		result1 float64
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetInt(arg1 string) (int, error) {
	fake.getIntMutex.Lock()
	ret, specificReturn := fake.getIntReturnsOnCall[len(fake.getIntArgsForCall)]
	fake.getIntArgsForCall = append(fake.getIntArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetIntStub
	fakeReturns := fake.getIntReturns
	fake.recordInvocation("GetInt", []interface{}{arg1})
	fake.getIntMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetIntCallCount() int {
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	return len(fake.getIntArgsForCall)
}

func (fake *FakePluginConfig) GetIntCalls(stub func(string) (int, error)) {
	fake.getIntMutex.Lock()
	defer fake.getIntMutex.Unlock()
	fake.GetIntStub = stub
}

func (fake *FakePluginConfig) GetIntArgsForCall(i int) string {
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	argsForCall := fake.getIntArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetIntReturns(result1 int, result2 error) {
	fake.getIntMutex.Lock()
	defer fake.getIntMutex.Unlock()
	fake.GetIntStub = nil
	fake.getIntReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntReturnsOnCall(i int, result1 int, result2 error) {
	fake.getIntMutex.Lock()
	defer fake.getIntMutex.Unlock()
	fake.GetIntStub = nil
	if fake.getIntReturnsOnCall == nil {
		fake.getIntReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getIntReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntSlice(arg1 string) ([]int, error) {
	fake.getIntSliceMutex.Lock()
	ret, specificReturn := fake.getIntSliceReturnsOnCall[len(fake.getIntSliceArgsForCall)]
	fake.getIntSliceArgsForCall = append(fake.getIntSliceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetIntSliceStub
	fakeReturns := fake.getIntSliceReturns
	fake.recordInvocation("GetIntSlice", []interface{}{arg1})
	fake.getIntSliceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetIntSliceCallCount() int {
	fake.getIntSliceMutex.RLock()
	defer fake.getIntSliceMutex.RUnlock()
	return len(fake.getIntSliceArgsForCall)
}

func (fake *FakePluginConfig) GetIntSliceCalls(stub func(string) ([]int, error)) {
	fake.getIntSliceMutex.Lock()
	defer fake.getIntSliceMutex.Unlock()
	fake.GetIntSliceStub = stub
}

func (fake *FakePluginConfig) GetIntSliceArgsForCall(i int) string {
	fake.getIntSliceMutex.RLock()
	defer fake.getIntSliceMutex.RUnlock()
	argsForCall := fake.getIntSliceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetIntSliceReturns(result1 []int, result2 error) {
	fake.getIntSliceMutex.Lock()
	defer fake.getIntSliceMutex.Unlock()
	fake.GetIntSliceStub = nil
	fake.getIntSliceReturns = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntSliceReturnsOnCall(i int, result1 []int, result2 error) {
	fake.getIntSliceMutex.Lock()
	defer fake.getIntSliceMutex.Unlock()
	fake.GetIntSliceStub = nil
	if fake.getIntSliceReturnsOnCall == nil {
		fake.getIntSliceReturnsOnCall = make(map[int]struct {
			result1 []int
			result2 error
		})
	}
	fake.getIntSliceReturnsOnCall[i] = struct {
		result1 []int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntWithDefault(arg1 string, arg2 int) (int, error) {
	fake.getIntWithDefaultMutex.Lock()
	ret, specificReturn := fake.getIntWithDefaultReturnsOnCall[len(fake.getIntWithDefaultArgsForCall)]
	fake.getIntWithDefaultArgsForCall = append(fake.getIntWithDefaultArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	stub := fake.GetIntWithDefaultStub
	fakeReturns := fake.getIntWithDefaultReturns
	fake.recordInvocation("GetIntWithDefault", []interface{}{arg1, arg2})
	fake.getIntWithDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetIntWithDefaultCallCount() int {
	fake.getIntWithDefaultMutex.RLock()
	defer fake.getIntWithDefaultMutex.RUnlock()
	return len(fake.getIntWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetIntWithDefaultCalls(stub func(string, int) (int, error)) {
	fake.getIntWithDefaultMutex.Lock()
	defer fake.getIntWithDefaultMutex.Unlock()
	fake.GetIntWithDefaultStub = stub
}

func (fake *FakePluginConfig) GetIntWithDefaultArgsForCall(i int) (string, int) {
	fake.getIntWithDefaultMutex.RLock()
	defer fake.getIntWithDefaultMutex.RUnlock()
	argsForCall := fake.getIntWithDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfig) GetIntWithDefaultReturns(result1 int, result2 error) {
	fake.getIntWithDefaultMutex.Lock()
	defer fake.getIntWithDefaultMutex.Unlock()
	fake.GetIntWithDefaultStub = nil
	fake.getIntWithDefaultReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetIntWithDefaultReturnsOnCall(i int, result1 int, result2 error) {
	fake.getIntWithDefaultMutex.Lock()
	defer fake.getIntWithDefaultMutex.Unlock()
	fake.GetIntWithDefaultStub = nil
	if fake.getIntWithDefaultReturnsOnCall == nil {
		fake.getIntWithDefaultReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getIntWithDefaultReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetString(arg1 string) (string, error) {
	fake.getStringMutex.Lock()
	ret, specificReturn := fake.getStringReturnsOnCall[len(fake.getStringArgsForCall)]
	fake.getStringArgsForCall = append(fake.getStringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStringStub
	fakeReturns := fake.getStringReturns
	fake.recordInvocation("GetString", []interface{}{arg1})
	fake.getStringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetStringCallCount() int {
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	return len(fake.getStringArgsForCall)
}

func (fake *FakePluginConfig) GetStringCalls(stub func(string) (string, error)) {
	fake.getStringMutex.Lock()
	defer fake.getStringMutex.Unlock()
	fake.GetStringStub = stub
}

func (fake *FakePluginConfig) GetStringArgsForCall(i int) string {
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	argsForCall := fake.getStringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetStringReturns(result1 string, result2 error) {
	fake.getStringMutex.Lock()
	defer fake.getStringMutex.Unlock()
	fake.GetStringStub = nil
	fake.getStringReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringReturnsOnCall(i int, result1 string, result2 error) {
	fake.getStringMutex.Lock()
	defer fake.getStringMutex.Unlock()
	fake.GetStringStub = nil
	if fake.getStringReturnsOnCall == nil {
		fake.getStringReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStringReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMap(arg1 string) (map[string]interface{}, error) {
	fake.getStringMapMutex.Lock()
	ret, specificReturn := fake.getStringMapReturnsOnCall[len(fake.getStringMapArgsForCall)]
	fake.getStringMapArgsForCall = append(fake.getStringMapArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStringMapStub
	fakeReturns := fake.getStringMapReturns
	fake.recordInvocation("GetStringMap", []interface{}{arg1})
	fake.getStringMapMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetStringMapCallCount() int {
	fake.getStringMapMutex.RLock()
	defer fake.getStringMapMutex.RUnlock()
	return len(fake.getStringMapArgsForCall)
}

func (fake *FakePluginConfig) GetStringMapCalls(stub func(string) (map[string]interface{}, error)) {
	fake.getStringMapMutex.Lock()
	defer fake.getStringMapMutex.Unlock()
	fake.GetStringMapStub = stub
}

func (fake *FakePluginConfig) GetStringMapArgsForCall(i int) string {
	fake.getStringMapMutex.RLock()
	defer fake.getStringMapMutex.RUnlock()
	argsForCall := fake.getStringMapArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetStringMapReturns(result1 map[string]interface{}, result2 error) {
	fake.getStringMapMutex.Lock()
	defer fake.getStringMapMutex.Unlock()
	fake.GetStringMapStub = nil
	fake.getStringMapReturns = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMapReturnsOnCall(i int, result1 map[string]interface{}, result2 error) {
	fake.getStringMapMutex.Lock()
	defer fake.getStringMapMutex.Unlock()
	fake.GetStringMapStub = nil
	if fake.getStringMapReturnsOnCall == nil {
		fake.getStringMapReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
			result2 error
		})
	}
	fake.getStringMapReturnsOnCall[i] = struct {
		result1 map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMapString(arg1 string) (map[string]string, error) {
	fake.getStringMapStringMutex.Lock()
	ret, specificReturn := fake.getStringMapStringReturnsOnCall[len(fake.getStringMapStringArgsForCall)]
	fake.getStringMapStringArgsForCall = append(fake.getStringMapStringArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStringMapStringStub
	fakeReturns := fake.getStringMapStringReturns
	fake.recordInvocation("GetStringMapString", []interface{}{arg1})
	fake.getStringMapStringMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetStringMapStringCallCount() int {
	fake.getStringMapStringMutex.RLock()
	defer fake.getStringMapStringMutex.RUnlock()
	return len(fake.getStringMapStringArgsForCall)
}

func (fake *FakePluginConfig) GetStringMapStringCalls(stub func(string) (map[string]string, error)) {
	fake.getStringMapStringMutex.Lock()
	defer fake.getStringMapStringMutex.Unlock()
	fake.GetStringMapStringStub = stub
}

func (fake *FakePluginConfig) GetStringMapStringArgsForCall(i int) string {
	fake.getStringMapStringMutex.RLock()
	defer fake.getStringMapStringMutex.RUnlock()
	argsForCall := fake.getStringMapStringArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetStringMapStringReturns(result1 map[string]string, result2 error) {
	fake.getStringMapStringMutex.Lock()
	defer fake.getStringMapStringMutex.Unlock()
	fake.GetStringMapStringStub = nil
	fake.getStringMapStringReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringMapStringReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.getStringMapStringMutex.Lock()
	defer fake.getStringMapStringMutex.Unlock()
	fake.GetStringMapStringStub = nil
	if fake.getStringMapStringReturnsOnCall == nil {
		fake.getStringMapStringReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getStringMapStringReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringSlice(arg1 string) ([]string, error) {
	fake.getStringSliceMutex.Lock()
	ret, specificReturn := fake.getStringSliceReturnsOnCall[len(fake.getStringSliceArgsForCall)]
	fake.getStringSliceArgsForCall = append(fake.getStringSliceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetStringSliceStub
	fakeReturns := fake.getStringSliceReturns
	fake.recordInvocation("GetStringSlice", []interface{}{arg1})
	fake.getStringSliceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetStringSliceCallCount() int {
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	return len(fake.getStringSliceArgsForCall)
}

func (fake *FakePluginConfig) GetStringSliceCalls(stub func(string) ([]string, error)) {
	fake.getStringSliceMutex.Lock()
	defer fake.getStringSliceMutex.Unlock()
	fake.GetStringSliceStub = stub
}

func (fake *FakePluginConfig) GetStringSliceArgsForCall(i int) string {
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	argsForCall := fake.getStringSliceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginConfig) GetStringSliceReturns(result1 []string, result2 error) {
	fake.getStringSliceMutex.Lock()
	defer fake.getStringSliceMutex.Unlock()
	fake.GetStringSliceStub = nil
	fake.getStringSliceReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringSliceReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getStringSliceMutex.Lock()
	defer fake.getStringSliceMutex.Unlock()
	fake.GetStringSliceStub = nil
	if fake.getStringSliceReturnsOnCall == nil {
		fake.getStringSliceReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getStringSliceReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringWithDefault(arg1 string, arg2 string) (string, error) {
	fake.getStringWithDefaultMutex.Lock()
	ret, specificReturn := fake.getStringWithDefaultReturnsOnCall[len(fake.getStringWithDefaultArgsForCall)]
	fake.getStringWithDefaultArgsForCall = append(fake.getStringWithDefaultArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStringWithDefaultStub
	fakeReturns := fake.getStringWithDefaultReturns
	fake.recordInvocation("GetStringWithDefault", []interface{}{arg1, arg2})
	fake.getStringWithDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginConfig) GetStringWithDefaultCallCount() int {
	fake.getStringWithDefaultMutex.RLock()
	defer fake.getStringWithDefaultMutex.RUnlock()
	return len(fake.getStringWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetStringWithDefaultCalls(stub func(string, string) (string, error)) {
	fake.getStringWithDefaultMutex.Lock()
	defer fake.getStringWithDefaultMutex.Unlock()
	fake.GetStringWithDefaultStub = stub
}

func (fake *FakePluginConfig) GetStringWithDefaultArgsForCall(i int) (string, string) {
	fake.getStringWithDefaultMutex.RLock()
	defer fake.getStringWithDefaultMutex.RUnlock()
	argsForCall := fake.getStringWithDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfig) GetStringWithDefaultReturns(result1 string, result2 error) {
	fake.getStringWithDefaultMutex.Lock()
	defer fake.getStringWithDefaultMutex.Unlock()
	fake.GetStringWithDefaultStub = nil
	fake.getStringWithDefaultReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetStringWithDefaultReturnsOnCall(i int, result1 string, result2 error) {
	fake.getStringWithDefaultMutex.Lock()
	defer fake.getStringWithDefaultMutex.Unlock()
	fake.GetStringWithDefaultStub = nil
	if fake.getStringWithDefaultReturnsOnCall == nil {
		fake.getStringWithDefaultReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getStringWithDefaultReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginConfig) GetWithDefault(arg1 string, arg2 interface{}) interface{} {
	fake.getWithDefaultMutex.Lock()
	ret, specificReturn := fake.getWithDefaultReturnsOnCall[len(fake.getWithDefaultArgsForCall)]
	fake.getWithDefaultArgsForCall = append(fake.getWithDefaultArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.GetWithDefaultStub
	fakeReturns := fake.getWithDefaultReturns
	fake.recordInvocation("GetWithDefault", []interface{}{arg1, arg2})
	fake.getWithDefaultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginConfig) GetWithDefaultCallCount() int {
	fake.getWithDefaultMutex.RLock()
	defer fake.getWithDefaultMutex.RUnlock()
	return len(fake.getWithDefaultArgsForCall)
}

func (fake *FakePluginConfig) GetWithDefaultCalls(stub func(string, interface{}) interface{}) {
	fake.getWithDefaultMutex.Lock()
	defer fake.getWithDefaultMutex.Unlock()
	fake.GetWithDefaultStub = stub
}

func (fake *FakePluginConfig) GetWithDefaultArgsForCall(i int) (string, interface{}) {
	fake.getWithDefaultMutex.RLock()
	defer fake.getWithDefaultMutex.RUnlock()
	argsForCall := fake.getWithDefaultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfig) GetWithDefaultReturns(result1 interface{}) {
	fake.getWithDefaultMutex.Lock()
	defer fake.getWithDefaultMutex.Unlock()
	fake.GetWithDefaultStub = nil
	fake.getWithDefaultReturns = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) GetWithDefaultReturnsOnCall(i int, result1 interface{}) {
	fake.getWithDefaultMutex.Lock()
	defer fake.getWithDefaultMutex.Unlock()
	fake.GetWithDefaultStub = nil
	if fake.getWithDefaultReturnsOnCall == nil {
		fake.getWithDefaultReturnsOnCall = make(map[int]struct {
			result1 interface{}
		})
	}
	fake.getWithDefaultReturnsOnCall[i] = struct {
		result1 interface{}
	}{result1}
}

func (fake *FakePluginConfig) Set(arg1 string, arg2 interface{}) error {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.SetStub
	fakeReturns := fake.setReturns
	fake.recordInvocation("Set", []interface{}{arg1, arg2})
	fake.setMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginConfig) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakePluginConfig) SetCalls(stub func(string, interface{}) error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = stub
}

func (fake *FakePluginConfig) SetArgsForCall(i int) (string, interface{}) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	argsForCall := fake.setArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePluginConfig) SetReturns(result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) SetReturnsOnCall(i int, result1 error) {
	fake.setMutex.Lock()
	defer fake.setMutex.Unlock()
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePluginConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.eraseMutex.RLock()
	defer fake.eraseMutex.RUnlock()
	fake.existsMutex.RLock()
	defer fake.existsMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getBoolMutex.RLock()
	defer fake.getBoolMutex.RUnlock()
	fake.getBoolWithDefaultMutex.RLock()
	defer fake.getBoolWithDefaultMutex.RUnlock()
	fake.getFloatMutex.RLock()
	defer fake.getFloatMutex.RUnlock()
	fake.getFloatSliceMutex.RLock()
	defer fake.getFloatSliceMutex.RUnlock()
	fake.getFloatWithDefaultMutex.RLock()
	defer fake.getFloatWithDefaultMutex.RUnlock()
	fake.getIntMutex.RLock()
	defer fake.getIntMutex.RUnlock()
	fake.getIntSliceMutex.RLock()
	defer fake.getIntSliceMutex.RUnlock()
	fake.getIntWithDefaultMutex.RLock()
	defer fake.getIntWithDefaultMutex.RUnlock()
	fake.getStringMutex.RLock()
	defer fake.getStringMutex.RUnlock()
	fake.getStringMapMutex.RLock()
	defer fake.getStringMapMutex.RUnlock()
	fake.getStringMapStringMutex.RLock()
	defer fake.getStringMapStringMutex.RUnlock()
	fake.getStringSliceMutex.RLock()
	defer fake.getStringSliceMutex.RUnlock()
	fake.getStringWithDefaultMutex.RLock()
	defer fake.getStringWithDefaultMutex.RUnlock()
	fake.getWithDefaultMutex.RLock()
	defer fake.getWithDefaultMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePluginConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ plugin.PluginConfig = new(FakePluginConfig)
