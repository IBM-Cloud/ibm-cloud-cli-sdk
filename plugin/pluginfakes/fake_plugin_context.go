// Code generated by counterfeiter. DO NOT EDIT.
package pluginfakes

import (
	"sync"

	"github.com/IBM-Cloud/ibm-cloud-cli-sdk/bluemix/endpoints"
	"github.com/IBM-Cloud/ibm-cloud-cli-sdk/bluemix/models"
	"github.com/IBM-Cloud/ibm-cloud-cli-sdk/plugin"
)

type FakePluginContext struct {
	APIEndpointStub        func() string
	aPIEndpointMutex       sync.RWMutex
	aPIEndpointArgsForCall []struct {
	}
	aPIEndpointReturns struct {
		result1 string
	}
	aPIEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	CFStub        func() plugin.CFContext
	cFMutex       sync.RWMutex
	cFArgsForCall []struct {
	}
	cFReturns struct {
		result1 plugin.CFContext
	}
	cFReturnsOnCall map[int]struct {
		result1 plugin.CFContext
	}
	CFEEEnvIDStub        func() string
	cFEEEnvIDMutex       sync.RWMutex
	cFEEEnvIDArgsForCall []struct {
	}
	cFEEEnvIDReturns struct {
		result1 string
	}
	cFEEEnvIDReturnsOnCall map[int]struct {
		result1 string
	}
	CLINameStub        func() string
	cLINameMutex       sync.RWMutex
	cLINameArgsForCall []struct {
	}
	cLINameReturns struct {
		result1 string
	}
	cLINameReturnsOnCall map[int]struct {
		result1 string
	}
	CRITypeStub        func() string
	cRITypeMutex       sync.RWMutex
	cRITypeArgsForCall []struct {
	}
	cRITypeReturns struct {
		result1 string
	}
	cRITypeReturnsOnCall map[int]struct {
		result1 string
	}
	CloudNameStub        func() string
	cloudNameMutex       sync.RWMutex
	cloudNameArgsForCall []struct {
	}
	cloudNameReturns struct {
		result1 string
	}
	cloudNameReturnsOnCall map[int]struct {
		result1 string
	}
	CloudTypeStub        func() string
	cloudTypeMutex       sync.RWMutex
	cloudTypeArgsForCall []struct {
	}
	cloudTypeReturns struct {
		result1 string
	}
	cloudTypeReturnsOnCall map[int]struct {
		result1 string
	}
	ColorEnabledStub        func() string
	colorEnabledMutex       sync.RWMutex
	colorEnabledArgsForCall []struct {
	}
	colorEnabledReturns struct {
		result1 string
	}
	colorEnabledReturnsOnCall map[int]struct {
		result1 string
	}
	CommandNamespaceStub        func() string
	commandNamespaceMutex       sync.RWMutex
	commandNamespaceArgsForCall []struct {
	}
	commandNamespaceReturns struct {
		result1 string
	}
	commandNamespaceReturnsOnCall map[int]struct {
		result1 string
	}
	ConsoleEndpointStub        func() string
	consoleEndpointMutex       sync.RWMutex
	consoleEndpointArgsForCall []struct {
	}
	consoleEndpointReturns struct {
		result1 string
	}
	consoleEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	ConsoleEndpointsStub        func() models.Endpoints
	consoleEndpointsMutex       sync.RWMutex
	consoleEndpointsArgsForCall []struct {
	}
	consoleEndpointsReturns struct {
		result1 models.Endpoints
	}
	consoleEndpointsReturnsOnCall map[int]struct {
		result1 models.Endpoints
	}
	CurrentAccountStub        func() models.Account
	currentAccountMutex       sync.RWMutex
	currentAccountArgsForCall []struct {
	}
	currentAccountReturns struct {
		result1 models.Account
	}
	currentAccountReturnsOnCall map[int]struct {
		result1 models.Account
	}
	CurrentProfileStub        func() models.Profile
	currentProfileMutex       sync.RWMutex
	currentProfileArgsForCall []struct {
	}
	currentProfileReturns struct {
		result1 models.Profile
	}
	currentProfileReturnsOnCall map[int]struct {
		result1 models.Profile
	}
	CurrentRegionStub        func() models.Region
	currentRegionMutex       sync.RWMutex
	currentRegionArgsForCall []struct {
	}
	currentRegionReturns struct {
		result1 models.Region
	}
	currentRegionReturnsOnCall map[int]struct {
		result1 models.Region
	}
	CurrentResourceGroupStub        func() models.ResourceGroup
	currentResourceGroupMutex       sync.RWMutex
	currentResourceGroupArgsForCall []struct {
	}
	currentResourceGroupReturns struct {
		result1 models.ResourceGroup
	}
	currentResourceGroupReturnsOnCall map[int]struct {
		result1 models.ResourceGroup
	}
	GetEndpointStub        func(endpoints.Service) (string, error)
	getEndpointMutex       sync.RWMutex
	getEndpointArgsForCall []struct {
		arg1 endpoints.Service
	}
	getEndpointReturns struct {
		result1 string
		result2 error
	}
	getEndpointReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	HTTPTimeoutStub        func() int
	hTTPTimeoutMutex       sync.RWMutex
	hTTPTimeoutArgsForCall []struct {
	}
	hTTPTimeoutReturns struct {
		result1 int
	}
	hTTPTimeoutReturnsOnCall map[int]struct {
		result1 int
	}
	HasAPIEndpointStub        func() bool
	hasAPIEndpointMutex       sync.RWMutex
	hasAPIEndpointArgsForCall []struct {
	}
	hasAPIEndpointReturns struct {
		result1 bool
	}
	hasAPIEndpointReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedAccountStub        func() bool
	hasTargetedAccountMutex       sync.RWMutex
	hasTargetedAccountArgsForCall []struct {
	}
	hasTargetedAccountReturns struct {
		result1 bool
	}
	hasTargetedAccountReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedCFStub        func() bool
	hasTargetedCFMutex       sync.RWMutex
	hasTargetedCFArgsForCall []struct {
	}
	hasTargetedCFReturns struct {
		result1 bool
	}
	hasTargetedCFReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedCFEEStub        func() bool
	hasTargetedCFEEMutex       sync.RWMutex
	hasTargetedCFEEArgsForCall []struct {
	}
	hasTargetedCFEEReturns struct {
		result1 bool
	}
	hasTargetedCFEEReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedComputeResourceStub        func() bool
	hasTargetedComputeResourceMutex       sync.RWMutex
	hasTargetedComputeResourceArgsForCall []struct {
	}
	hasTargetedComputeResourceReturns struct {
		result1 bool
	}
	hasTargetedComputeResourceReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedProfileStub        func() bool
	hasTargetedProfileMutex       sync.RWMutex
	hasTargetedProfileArgsForCall []struct {
	}
	hasTargetedProfileReturns struct {
		result1 bool
	}
	hasTargetedProfileReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedPublicCFStub        func() bool
	hasTargetedPublicCFMutex       sync.RWMutex
	hasTargetedPublicCFArgsForCall []struct {
	}
	hasTargetedPublicCFReturns struct {
		result1 bool
	}
	hasTargetedPublicCFReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedRegionStub        func() bool
	hasTargetedRegionMutex       sync.RWMutex
	hasTargetedRegionArgsForCall []struct {
	}
	hasTargetedRegionReturns struct {
		result1 bool
	}
	hasTargetedRegionReturnsOnCall map[int]struct {
		result1 bool
	}
	HasTargetedResourceGroupStub        func() bool
	hasTargetedResourceGroupMutex       sync.RWMutex
	hasTargetedResourceGroupArgsForCall []struct {
	}
	hasTargetedResourceGroupReturns struct {
		result1 bool
	}
	hasTargetedResourceGroupReturnsOnCall map[int]struct {
		result1 bool
	}
	IAMEndpointStub        func() string
	iAMEndpointMutex       sync.RWMutex
	iAMEndpointArgsForCall []struct {
	}
	iAMEndpointReturns struct {
		result1 string
	}
	iAMEndpointReturnsOnCall map[int]struct {
		result1 string
	}
	IAMEndpointsStub        func() models.Endpoints
	iAMEndpointsMutex       sync.RWMutex
	iAMEndpointsArgsForCall []struct {
	}
	iAMEndpointsReturns struct {
		result1 models.Endpoints
	}
	iAMEndpointsReturnsOnCall map[int]struct {
		result1 models.Endpoints
	}
	IAMRefreshTokenStub        func() string
	iAMRefreshTokenMutex       sync.RWMutex
	iAMRefreshTokenArgsForCall []struct {
	}
	iAMRefreshTokenReturns struct {
		result1 string
	}
	iAMRefreshTokenReturnsOnCall map[int]struct {
		result1 string
	}
	IAMTokenStub        func() string
	iAMTokenMutex       sync.RWMutex
	iAMTokenArgsForCall []struct {
	}
	iAMTokenReturns struct {
		result1 string
	}
	iAMTokenReturnsOnCall map[int]struct {
		result1 string
	}
	IMSAccountIDStub        func() string
	iMSAccountIDMutex       sync.RWMutex
	iMSAccountIDArgsForCall []struct {
	}
	iMSAccountIDReturns struct {
		result1 string
	}
	iMSAccountIDReturnsOnCall map[int]struct {
		result1 string
	}
	IsLoggedInStub        func() bool
	isLoggedInMutex       sync.RWMutex
	isLoggedInArgsForCall []struct {
	}
	isLoggedInReturns struct {
		result1 bool
	}
	isLoggedInReturnsOnCall map[int]struct {
		result1 bool
	}
	IsLoggedInAsCRIStub        func() bool
	isLoggedInAsCRIMutex       sync.RWMutex
	isLoggedInAsCRIArgsForCall []struct {
	}
	isLoggedInAsCRIReturns struct {
		result1 bool
	}
	isLoggedInAsCRIReturnsOnCall map[int]struct {
		result1 bool
	}
	IsLoggedInAsProfileStub        func() bool
	isLoggedInAsProfileMutex       sync.RWMutex
	isLoggedInAsProfileArgsForCall []struct {
	}
	isLoggedInAsProfileReturns struct {
		result1 bool
	}
	isLoggedInAsProfileReturnsOnCall map[int]struct {
		result1 bool
	}
	IsLoggedInWithServiceIDStub        func() bool
	isLoggedInWithServiceIDMutex       sync.RWMutex
	isLoggedInWithServiceIDArgsForCall []struct {
	}
	isLoggedInWithServiceIDReturns struct {
		result1 bool
	}
	isLoggedInWithServiceIDReturnsOnCall map[int]struct {
		result1 bool
	}
	IsPrivateEndpointEnabledStub        func() bool
	isPrivateEndpointEnabledMutex       sync.RWMutex
	isPrivateEndpointEnabledArgsForCall []struct {
	}
	isPrivateEndpointEnabledReturns struct {
		result1 bool
	}
	isPrivateEndpointEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSSLDisabledStub        func() bool
	isSSLDisabledMutex       sync.RWMutex
	isSSLDisabledArgsForCall []struct {
	}
	isSSLDisabledReturns struct {
		result1 bool
	}
	isSSLDisabledReturnsOnCall map[int]struct {
		result1 bool
	}
	LocaleStub        func() string
	localeMutex       sync.RWMutex
	localeArgsForCall []struct {
	}
	localeReturns struct {
		result1 string
	}
	localeReturnsOnCall map[int]struct {
		result1 string
	}
	PluginConfigStub        func() plugin.PluginConfig
	pluginConfigMutex       sync.RWMutex
	pluginConfigArgsForCall []struct {
	}
	pluginConfigReturns struct {
		result1 plugin.PluginConfig
	}
	pluginConfigReturnsOnCall map[int]struct {
		result1 plugin.PluginConfig
	}
	PluginDirectoryStub        func() string
	pluginDirectoryMutex       sync.RWMutex
	pluginDirectoryArgsForCall []struct {
	}
	pluginDirectoryReturns struct {
		result1 string
	}
	pluginDirectoryReturnsOnCall map[int]struct {
		result1 string
	}
	RefreshIAMTokenStub        func() (string, error)
	refreshIAMTokenMutex       sync.RWMutex
	refreshIAMTokenArgsForCall []struct {
	}
	refreshIAMTokenReturns struct {
		result1 string
		result2 error
	}
	refreshIAMTokenReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	TraceStub        func() string
	traceMutex       sync.RWMutex
	traceArgsForCall []struct {
	}
	traceReturns struct {
		result1 string
	}
	traceReturnsOnCall map[int]struct {
		result1 string
	}
	UserEmailStub        func() string
	userEmailMutex       sync.RWMutex
	userEmailArgsForCall []struct {
	}
	userEmailReturns struct {
		result1 string
	}
	userEmailReturnsOnCall map[int]struct {
		result1 string
	}
	VPCCRITokenURLStub        func() string
	vPCCRITokenURLMutex       sync.RWMutex
	vPCCRITokenURLArgsForCall []struct {
	}
	vPCCRITokenURLReturns struct {
		result1 string
	}
	vPCCRITokenURLReturnsOnCall map[int]struct {
		result1 string
	}
	VersionCheckEnabledStub        func() bool
	versionCheckEnabledMutex       sync.RWMutex
	versionCheckEnabledArgsForCall []struct {
	}
	versionCheckEnabledReturns struct {
		result1 bool
	}
	versionCheckEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePluginContext) APIEndpoint() string {
	fake.aPIEndpointMutex.Lock()
	ret, specificReturn := fake.aPIEndpointReturnsOnCall[len(fake.aPIEndpointArgsForCall)]
	fake.aPIEndpointArgsForCall = append(fake.aPIEndpointArgsForCall, struct {
	}{})
	stub := fake.APIEndpointStub
	fakeReturns := fake.aPIEndpointReturns
	fake.recordInvocation("APIEndpoint", []interface{}{})
	fake.aPIEndpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) APIEndpointCallCount() int {
	fake.aPIEndpointMutex.RLock()
	defer fake.aPIEndpointMutex.RUnlock()
	return len(fake.aPIEndpointArgsForCall)
}

func (fake *FakePluginContext) APIEndpointCalls(stub func() string) {
	fake.aPIEndpointMutex.Lock()
	defer fake.aPIEndpointMutex.Unlock()
	fake.APIEndpointStub = stub
}

func (fake *FakePluginContext) APIEndpointReturns(result1 string) {
	fake.aPIEndpointMutex.Lock()
	defer fake.aPIEndpointMutex.Unlock()
	fake.APIEndpointStub = nil
	fake.aPIEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) APIEndpointReturnsOnCall(i int, result1 string) {
	fake.aPIEndpointMutex.Lock()
	defer fake.aPIEndpointMutex.Unlock()
	fake.APIEndpointStub = nil
	if fake.aPIEndpointReturnsOnCall == nil {
		fake.aPIEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.aPIEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CF() plugin.CFContext {
	fake.cFMutex.Lock()
	ret, specificReturn := fake.cFReturnsOnCall[len(fake.cFArgsForCall)]
	fake.cFArgsForCall = append(fake.cFArgsForCall, struct {
	}{})
	stub := fake.CFStub
	fakeReturns := fake.cFReturns
	fake.recordInvocation("CF", []interface{}{})
	fake.cFMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CFCallCount() int {
	fake.cFMutex.RLock()
	defer fake.cFMutex.RUnlock()
	return len(fake.cFArgsForCall)
}

func (fake *FakePluginContext) CFCalls(stub func() plugin.CFContext) {
	fake.cFMutex.Lock()
	defer fake.cFMutex.Unlock()
	fake.CFStub = stub
}

func (fake *FakePluginContext) CFReturns(result1 plugin.CFContext) {
	fake.cFMutex.Lock()
	defer fake.cFMutex.Unlock()
	fake.CFStub = nil
	fake.cFReturns = struct {
		result1 plugin.CFContext
	}{result1}
}

func (fake *FakePluginContext) CFReturnsOnCall(i int, result1 plugin.CFContext) {
	fake.cFMutex.Lock()
	defer fake.cFMutex.Unlock()
	fake.CFStub = nil
	if fake.cFReturnsOnCall == nil {
		fake.cFReturnsOnCall = make(map[int]struct {
			result1 plugin.CFContext
		})
	}
	fake.cFReturnsOnCall[i] = struct {
		result1 plugin.CFContext
	}{result1}
}

func (fake *FakePluginContext) CFEEEnvID() string {
	fake.cFEEEnvIDMutex.Lock()
	ret, specificReturn := fake.cFEEEnvIDReturnsOnCall[len(fake.cFEEEnvIDArgsForCall)]
	fake.cFEEEnvIDArgsForCall = append(fake.cFEEEnvIDArgsForCall, struct {
	}{})
	stub := fake.CFEEEnvIDStub
	fakeReturns := fake.cFEEEnvIDReturns
	fake.recordInvocation("CFEEEnvID", []interface{}{})
	fake.cFEEEnvIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CFEEEnvIDCallCount() int {
	fake.cFEEEnvIDMutex.RLock()
	defer fake.cFEEEnvIDMutex.RUnlock()
	return len(fake.cFEEEnvIDArgsForCall)
}

func (fake *FakePluginContext) CFEEEnvIDCalls(stub func() string) {
	fake.cFEEEnvIDMutex.Lock()
	defer fake.cFEEEnvIDMutex.Unlock()
	fake.CFEEEnvIDStub = stub
}

func (fake *FakePluginContext) CFEEEnvIDReturns(result1 string) {
	fake.cFEEEnvIDMutex.Lock()
	defer fake.cFEEEnvIDMutex.Unlock()
	fake.CFEEEnvIDStub = nil
	fake.cFEEEnvIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CFEEEnvIDReturnsOnCall(i int, result1 string) {
	fake.cFEEEnvIDMutex.Lock()
	defer fake.cFEEEnvIDMutex.Unlock()
	fake.CFEEEnvIDStub = nil
	if fake.cFEEEnvIDReturnsOnCall == nil {
		fake.cFEEEnvIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cFEEEnvIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CLIName() string {
	fake.cLINameMutex.Lock()
	ret, specificReturn := fake.cLINameReturnsOnCall[len(fake.cLINameArgsForCall)]
	fake.cLINameArgsForCall = append(fake.cLINameArgsForCall, struct {
	}{})
	stub := fake.CLINameStub
	fakeReturns := fake.cLINameReturns
	fake.recordInvocation("CLIName", []interface{}{})
	fake.cLINameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CLINameCallCount() int {
	fake.cLINameMutex.RLock()
	defer fake.cLINameMutex.RUnlock()
	return len(fake.cLINameArgsForCall)
}

func (fake *FakePluginContext) CLINameCalls(stub func() string) {
	fake.cLINameMutex.Lock()
	defer fake.cLINameMutex.Unlock()
	fake.CLINameStub = stub
}

func (fake *FakePluginContext) CLINameReturns(result1 string) {
	fake.cLINameMutex.Lock()
	defer fake.cLINameMutex.Unlock()
	fake.CLINameStub = nil
	fake.cLINameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CLINameReturnsOnCall(i int, result1 string) {
	fake.cLINameMutex.Lock()
	defer fake.cLINameMutex.Unlock()
	fake.CLINameStub = nil
	if fake.cLINameReturnsOnCall == nil {
		fake.cLINameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cLINameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CRIType() string {
	fake.cRITypeMutex.Lock()
	ret, specificReturn := fake.cRITypeReturnsOnCall[len(fake.cRITypeArgsForCall)]
	fake.cRITypeArgsForCall = append(fake.cRITypeArgsForCall, struct {
	}{})
	stub := fake.CRITypeStub
	fakeReturns := fake.cRITypeReturns
	fake.recordInvocation("CRIType", []interface{}{})
	fake.cRITypeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CRITypeCallCount() int {
	fake.cRITypeMutex.RLock()
	defer fake.cRITypeMutex.RUnlock()
	return len(fake.cRITypeArgsForCall)
}

func (fake *FakePluginContext) CRITypeCalls(stub func() string) {
	fake.cRITypeMutex.Lock()
	defer fake.cRITypeMutex.Unlock()
	fake.CRITypeStub = stub
}

func (fake *FakePluginContext) CRITypeReturns(result1 string) {
	fake.cRITypeMutex.Lock()
	defer fake.cRITypeMutex.Unlock()
	fake.CRITypeStub = nil
	fake.cRITypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CRITypeReturnsOnCall(i int, result1 string) {
	fake.cRITypeMutex.Lock()
	defer fake.cRITypeMutex.Unlock()
	fake.CRITypeStub = nil
	if fake.cRITypeReturnsOnCall == nil {
		fake.cRITypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cRITypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudName() string {
	fake.cloudNameMutex.Lock()
	ret, specificReturn := fake.cloudNameReturnsOnCall[len(fake.cloudNameArgsForCall)]
	fake.cloudNameArgsForCall = append(fake.cloudNameArgsForCall, struct {
	}{})
	stub := fake.CloudNameStub
	fakeReturns := fake.cloudNameReturns
	fake.recordInvocation("CloudName", []interface{}{})
	fake.cloudNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CloudNameCallCount() int {
	fake.cloudNameMutex.RLock()
	defer fake.cloudNameMutex.RUnlock()
	return len(fake.cloudNameArgsForCall)
}

func (fake *FakePluginContext) CloudNameCalls(stub func() string) {
	fake.cloudNameMutex.Lock()
	defer fake.cloudNameMutex.Unlock()
	fake.CloudNameStub = stub
}

func (fake *FakePluginContext) CloudNameReturns(result1 string) {
	fake.cloudNameMutex.Lock()
	defer fake.cloudNameMutex.Unlock()
	fake.CloudNameStub = nil
	fake.cloudNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudNameReturnsOnCall(i int, result1 string) {
	fake.cloudNameMutex.Lock()
	defer fake.cloudNameMutex.Unlock()
	fake.CloudNameStub = nil
	if fake.cloudNameReturnsOnCall == nil {
		fake.cloudNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cloudNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudType() string {
	fake.cloudTypeMutex.Lock()
	ret, specificReturn := fake.cloudTypeReturnsOnCall[len(fake.cloudTypeArgsForCall)]
	fake.cloudTypeArgsForCall = append(fake.cloudTypeArgsForCall, struct {
	}{})
	stub := fake.CloudTypeStub
	fakeReturns := fake.cloudTypeReturns
	fake.recordInvocation("CloudType", []interface{}{})
	fake.cloudTypeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CloudTypeCallCount() int {
	fake.cloudTypeMutex.RLock()
	defer fake.cloudTypeMutex.RUnlock()
	return len(fake.cloudTypeArgsForCall)
}

func (fake *FakePluginContext) CloudTypeCalls(stub func() string) {
	fake.cloudTypeMutex.Lock()
	defer fake.cloudTypeMutex.Unlock()
	fake.CloudTypeStub = stub
}

func (fake *FakePluginContext) CloudTypeReturns(result1 string) {
	fake.cloudTypeMutex.Lock()
	defer fake.cloudTypeMutex.Unlock()
	fake.CloudTypeStub = nil
	fake.cloudTypeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CloudTypeReturnsOnCall(i int, result1 string) {
	fake.cloudTypeMutex.Lock()
	defer fake.cloudTypeMutex.Unlock()
	fake.CloudTypeStub = nil
	if fake.cloudTypeReturnsOnCall == nil {
		fake.cloudTypeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cloudTypeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ColorEnabled() string {
	fake.colorEnabledMutex.Lock()
	ret, specificReturn := fake.colorEnabledReturnsOnCall[len(fake.colorEnabledArgsForCall)]
	fake.colorEnabledArgsForCall = append(fake.colorEnabledArgsForCall, struct {
	}{})
	stub := fake.ColorEnabledStub
	fakeReturns := fake.colorEnabledReturns
	fake.recordInvocation("ColorEnabled", []interface{}{})
	fake.colorEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) ColorEnabledCallCount() int {
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	return len(fake.colorEnabledArgsForCall)
}

func (fake *FakePluginContext) ColorEnabledCalls(stub func() string) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = stub
}

func (fake *FakePluginContext) ColorEnabledReturns(result1 string) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = nil
	fake.colorEnabledReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ColorEnabledReturnsOnCall(i int, result1 string) {
	fake.colorEnabledMutex.Lock()
	defer fake.colorEnabledMutex.Unlock()
	fake.ColorEnabledStub = nil
	if fake.colorEnabledReturnsOnCall == nil {
		fake.colorEnabledReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.colorEnabledReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CommandNamespace() string {
	fake.commandNamespaceMutex.Lock()
	ret, specificReturn := fake.commandNamespaceReturnsOnCall[len(fake.commandNamespaceArgsForCall)]
	fake.commandNamespaceArgsForCall = append(fake.commandNamespaceArgsForCall, struct {
	}{})
	stub := fake.CommandNamespaceStub
	fakeReturns := fake.commandNamespaceReturns
	fake.recordInvocation("CommandNamespace", []interface{}{})
	fake.commandNamespaceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CommandNamespaceCallCount() int {
	fake.commandNamespaceMutex.RLock()
	defer fake.commandNamespaceMutex.RUnlock()
	return len(fake.commandNamespaceArgsForCall)
}

func (fake *FakePluginContext) CommandNamespaceCalls(stub func() string) {
	fake.commandNamespaceMutex.Lock()
	defer fake.commandNamespaceMutex.Unlock()
	fake.CommandNamespaceStub = stub
}

func (fake *FakePluginContext) CommandNamespaceReturns(result1 string) {
	fake.commandNamespaceMutex.Lock()
	defer fake.commandNamespaceMutex.Unlock()
	fake.CommandNamespaceStub = nil
	fake.commandNamespaceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) CommandNamespaceReturnsOnCall(i int, result1 string) {
	fake.commandNamespaceMutex.Lock()
	defer fake.commandNamespaceMutex.Unlock()
	fake.CommandNamespaceStub = nil
	if fake.commandNamespaceReturnsOnCall == nil {
		fake.commandNamespaceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.commandNamespaceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpoint() string {
	fake.consoleEndpointMutex.Lock()
	ret, specificReturn := fake.consoleEndpointReturnsOnCall[len(fake.consoleEndpointArgsForCall)]
	fake.consoleEndpointArgsForCall = append(fake.consoleEndpointArgsForCall, struct {
	}{})
	stub := fake.ConsoleEndpointStub
	fakeReturns := fake.consoleEndpointReturns
	fake.recordInvocation("ConsoleEndpoint", []interface{}{})
	fake.consoleEndpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) ConsoleEndpointCallCount() int {
	fake.consoleEndpointMutex.RLock()
	defer fake.consoleEndpointMutex.RUnlock()
	return len(fake.consoleEndpointArgsForCall)
}

func (fake *FakePluginContext) ConsoleEndpointCalls(stub func() string) {
	fake.consoleEndpointMutex.Lock()
	defer fake.consoleEndpointMutex.Unlock()
	fake.ConsoleEndpointStub = stub
}

func (fake *FakePluginContext) ConsoleEndpointReturns(result1 string) {
	fake.consoleEndpointMutex.Lock()
	defer fake.consoleEndpointMutex.Unlock()
	fake.ConsoleEndpointStub = nil
	fake.consoleEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpointReturnsOnCall(i int, result1 string) {
	fake.consoleEndpointMutex.Lock()
	defer fake.consoleEndpointMutex.Unlock()
	fake.ConsoleEndpointStub = nil
	if fake.consoleEndpointReturnsOnCall == nil {
		fake.consoleEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.consoleEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpoints() models.Endpoints {
	fake.consoleEndpointsMutex.Lock()
	ret, specificReturn := fake.consoleEndpointsReturnsOnCall[len(fake.consoleEndpointsArgsForCall)]
	fake.consoleEndpointsArgsForCall = append(fake.consoleEndpointsArgsForCall, struct {
	}{})
	stub := fake.ConsoleEndpointsStub
	fakeReturns := fake.consoleEndpointsReturns
	fake.recordInvocation("ConsoleEndpoints", []interface{}{})
	fake.consoleEndpointsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) ConsoleEndpointsCallCount() int {
	fake.consoleEndpointsMutex.RLock()
	defer fake.consoleEndpointsMutex.RUnlock()
	return len(fake.consoleEndpointsArgsForCall)
}

func (fake *FakePluginContext) ConsoleEndpointsCalls(stub func() models.Endpoints) {
	fake.consoleEndpointsMutex.Lock()
	defer fake.consoleEndpointsMutex.Unlock()
	fake.ConsoleEndpointsStub = stub
}

func (fake *FakePluginContext) ConsoleEndpointsReturns(result1 models.Endpoints) {
	fake.consoleEndpointsMutex.Lock()
	defer fake.consoleEndpointsMutex.Unlock()
	fake.ConsoleEndpointsStub = nil
	fake.consoleEndpointsReturns = struct {
		result1 models.Endpoints
	}{result1}
}

func (fake *FakePluginContext) ConsoleEndpointsReturnsOnCall(i int, result1 models.Endpoints) {
	fake.consoleEndpointsMutex.Lock()
	defer fake.consoleEndpointsMutex.Unlock()
	fake.ConsoleEndpointsStub = nil
	if fake.consoleEndpointsReturnsOnCall == nil {
		fake.consoleEndpointsReturnsOnCall = make(map[int]struct {
			result1 models.Endpoints
		})
	}
	fake.consoleEndpointsReturnsOnCall[i] = struct {
		result1 models.Endpoints
	}{result1}
}

func (fake *FakePluginContext) CurrentAccount() models.Account {
	fake.currentAccountMutex.Lock()
	ret, specificReturn := fake.currentAccountReturnsOnCall[len(fake.currentAccountArgsForCall)]
	fake.currentAccountArgsForCall = append(fake.currentAccountArgsForCall, struct {
	}{})
	stub := fake.CurrentAccountStub
	fakeReturns := fake.currentAccountReturns
	fake.recordInvocation("CurrentAccount", []interface{}{})
	fake.currentAccountMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentAccountCallCount() int {
	fake.currentAccountMutex.RLock()
	defer fake.currentAccountMutex.RUnlock()
	return len(fake.currentAccountArgsForCall)
}

func (fake *FakePluginContext) CurrentAccountCalls(stub func() models.Account) {
	fake.currentAccountMutex.Lock()
	defer fake.currentAccountMutex.Unlock()
	fake.CurrentAccountStub = stub
}

func (fake *FakePluginContext) CurrentAccountReturns(result1 models.Account) {
	fake.currentAccountMutex.Lock()
	defer fake.currentAccountMutex.Unlock()
	fake.CurrentAccountStub = nil
	fake.currentAccountReturns = struct {
		result1 models.Account
	}{result1}
}

func (fake *FakePluginContext) CurrentAccountReturnsOnCall(i int, result1 models.Account) {
	fake.currentAccountMutex.Lock()
	defer fake.currentAccountMutex.Unlock()
	fake.CurrentAccountStub = nil
	if fake.currentAccountReturnsOnCall == nil {
		fake.currentAccountReturnsOnCall = make(map[int]struct {
			result1 models.Account
		})
	}
	fake.currentAccountReturnsOnCall[i] = struct {
		result1 models.Account
	}{result1}
}

func (fake *FakePluginContext) CurrentProfile() models.Profile {
	fake.currentProfileMutex.Lock()
	ret, specificReturn := fake.currentProfileReturnsOnCall[len(fake.currentProfileArgsForCall)]
	fake.currentProfileArgsForCall = append(fake.currentProfileArgsForCall, struct {
	}{})
	stub := fake.CurrentProfileStub
	fakeReturns := fake.currentProfileReturns
	fake.recordInvocation("CurrentProfile", []interface{}{})
	fake.currentProfileMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentProfileCallCount() int {
	fake.currentProfileMutex.RLock()
	defer fake.currentProfileMutex.RUnlock()
	return len(fake.currentProfileArgsForCall)
}

func (fake *FakePluginContext) CurrentProfileCalls(stub func() models.Profile) {
	fake.currentProfileMutex.Lock()
	defer fake.currentProfileMutex.Unlock()
	fake.CurrentProfileStub = stub
}

func (fake *FakePluginContext) CurrentProfileReturns(result1 models.Profile) {
	fake.currentProfileMutex.Lock()
	defer fake.currentProfileMutex.Unlock()
	fake.CurrentProfileStub = nil
	fake.currentProfileReturns = struct {
		result1 models.Profile
	}{result1}
}

func (fake *FakePluginContext) CurrentProfileReturnsOnCall(i int, result1 models.Profile) {
	fake.currentProfileMutex.Lock()
	defer fake.currentProfileMutex.Unlock()
	fake.CurrentProfileStub = nil
	if fake.currentProfileReturnsOnCall == nil {
		fake.currentProfileReturnsOnCall = make(map[int]struct {
			result1 models.Profile
		})
	}
	fake.currentProfileReturnsOnCall[i] = struct {
		result1 models.Profile
	}{result1}
}

func (fake *FakePluginContext) CurrentRegion() models.Region {
	fake.currentRegionMutex.Lock()
	ret, specificReturn := fake.currentRegionReturnsOnCall[len(fake.currentRegionArgsForCall)]
	fake.currentRegionArgsForCall = append(fake.currentRegionArgsForCall, struct {
	}{})
	stub := fake.CurrentRegionStub
	fakeReturns := fake.currentRegionReturns
	fake.recordInvocation("CurrentRegion", []interface{}{})
	fake.currentRegionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentRegionCallCount() int {
	fake.currentRegionMutex.RLock()
	defer fake.currentRegionMutex.RUnlock()
	return len(fake.currentRegionArgsForCall)
}

func (fake *FakePluginContext) CurrentRegionCalls(stub func() models.Region) {
	fake.currentRegionMutex.Lock()
	defer fake.currentRegionMutex.Unlock()
	fake.CurrentRegionStub = stub
}

func (fake *FakePluginContext) CurrentRegionReturns(result1 models.Region) {
	fake.currentRegionMutex.Lock()
	defer fake.currentRegionMutex.Unlock()
	fake.CurrentRegionStub = nil
	fake.currentRegionReturns = struct {
		result1 models.Region
	}{result1}
}

func (fake *FakePluginContext) CurrentRegionReturnsOnCall(i int, result1 models.Region) {
	fake.currentRegionMutex.Lock()
	defer fake.currentRegionMutex.Unlock()
	fake.CurrentRegionStub = nil
	if fake.currentRegionReturnsOnCall == nil {
		fake.currentRegionReturnsOnCall = make(map[int]struct {
			result1 models.Region
		})
	}
	fake.currentRegionReturnsOnCall[i] = struct {
		result1 models.Region
	}{result1}
}

func (fake *FakePluginContext) CurrentResourceGroup() models.ResourceGroup {
	fake.currentResourceGroupMutex.Lock()
	ret, specificReturn := fake.currentResourceGroupReturnsOnCall[len(fake.currentResourceGroupArgsForCall)]
	fake.currentResourceGroupArgsForCall = append(fake.currentResourceGroupArgsForCall, struct {
	}{})
	stub := fake.CurrentResourceGroupStub
	fakeReturns := fake.currentResourceGroupReturns
	fake.recordInvocation("CurrentResourceGroup", []interface{}{})
	fake.currentResourceGroupMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) CurrentResourceGroupCallCount() int {
	fake.currentResourceGroupMutex.RLock()
	defer fake.currentResourceGroupMutex.RUnlock()
	return len(fake.currentResourceGroupArgsForCall)
}

func (fake *FakePluginContext) CurrentResourceGroupCalls(stub func() models.ResourceGroup) {
	fake.currentResourceGroupMutex.Lock()
	defer fake.currentResourceGroupMutex.Unlock()
	fake.CurrentResourceGroupStub = stub
}

func (fake *FakePluginContext) CurrentResourceGroupReturns(result1 models.ResourceGroup) {
	fake.currentResourceGroupMutex.Lock()
	defer fake.currentResourceGroupMutex.Unlock()
	fake.CurrentResourceGroupStub = nil
	fake.currentResourceGroupReturns = struct {
		result1 models.ResourceGroup
	}{result1}
}

func (fake *FakePluginContext) CurrentResourceGroupReturnsOnCall(i int, result1 models.ResourceGroup) {
	fake.currentResourceGroupMutex.Lock()
	defer fake.currentResourceGroupMutex.Unlock()
	fake.CurrentResourceGroupStub = nil
	if fake.currentResourceGroupReturnsOnCall == nil {
		fake.currentResourceGroupReturnsOnCall = make(map[int]struct {
			result1 models.ResourceGroup
		})
	}
	fake.currentResourceGroupReturnsOnCall[i] = struct {
		result1 models.ResourceGroup
	}{result1}
}

func (fake *FakePluginContext) GetEndpoint(arg1 endpoints.Service) (string, error) {
	fake.getEndpointMutex.Lock()
	ret, specificReturn := fake.getEndpointReturnsOnCall[len(fake.getEndpointArgsForCall)]
	fake.getEndpointArgsForCall = append(fake.getEndpointArgsForCall, struct {
		arg1 endpoints.Service
	}{arg1})
	stub := fake.GetEndpointStub
	fakeReturns := fake.getEndpointReturns
	fake.recordInvocation("GetEndpoint", []interface{}{arg1})
	fake.getEndpointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginContext) GetEndpointCallCount() int {
	fake.getEndpointMutex.RLock()
	defer fake.getEndpointMutex.RUnlock()
	return len(fake.getEndpointArgsForCall)
}

func (fake *FakePluginContext) GetEndpointCalls(stub func(endpoints.Service) (string, error)) {
	fake.getEndpointMutex.Lock()
	defer fake.getEndpointMutex.Unlock()
	fake.GetEndpointStub = stub
}

func (fake *FakePluginContext) GetEndpointArgsForCall(i int) endpoints.Service {
	fake.getEndpointMutex.RLock()
	defer fake.getEndpointMutex.RUnlock()
	argsForCall := fake.getEndpointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePluginContext) GetEndpointReturns(result1 string, result2 error) {
	fake.getEndpointMutex.Lock()
	defer fake.getEndpointMutex.Unlock()
	fake.GetEndpointStub = nil
	fake.getEndpointReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) GetEndpointReturnsOnCall(i int, result1 string, result2 error) {
	fake.getEndpointMutex.Lock()
	defer fake.getEndpointMutex.Unlock()
	fake.GetEndpointStub = nil
	if fake.getEndpointReturnsOnCall == nil {
		fake.getEndpointReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getEndpointReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) HTTPTimeout() int {
	fake.hTTPTimeoutMutex.Lock()
	ret, specificReturn := fake.hTTPTimeoutReturnsOnCall[len(fake.hTTPTimeoutArgsForCall)]
	fake.hTTPTimeoutArgsForCall = append(fake.hTTPTimeoutArgsForCall, struct {
	}{})
	stub := fake.HTTPTimeoutStub
	fakeReturns := fake.hTTPTimeoutReturns
	fake.recordInvocation("HTTPTimeout", []interface{}{})
	fake.hTTPTimeoutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HTTPTimeoutCallCount() int {
	fake.hTTPTimeoutMutex.RLock()
	defer fake.hTTPTimeoutMutex.RUnlock()
	return len(fake.hTTPTimeoutArgsForCall)
}

func (fake *FakePluginContext) HTTPTimeoutCalls(stub func() int) {
	fake.hTTPTimeoutMutex.Lock()
	defer fake.hTTPTimeoutMutex.Unlock()
	fake.HTTPTimeoutStub = stub
}

func (fake *FakePluginContext) HTTPTimeoutReturns(result1 int) {
	fake.hTTPTimeoutMutex.Lock()
	defer fake.hTTPTimeoutMutex.Unlock()
	fake.HTTPTimeoutStub = nil
	fake.hTTPTimeoutReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePluginContext) HTTPTimeoutReturnsOnCall(i int, result1 int) {
	fake.hTTPTimeoutMutex.Lock()
	defer fake.hTTPTimeoutMutex.Unlock()
	fake.HTTPTimeoutStub = nil
	if fake.hTTPTimeoutReturnsOnCall == nil {
		fake.hTTPTimeoutReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.hTTPTimeoutReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePluginContext) HasAPIEndpoint() bool {
	fake.hasAPIEndpointMutex.Lock()
	ret, specificReturn := fake.hasAPIEndpointReturnsOnCall[len(fake.hasAPIEndpointArgsForCall)]
	fake.hasAPIEndpointArgsForCall = append(fake.hasAPIEndpointArgsForCall, struct {
	}{})
	stub := fake.HasAPIEndpointStub
	fakeReturns := fake.hasAPIEndpointReturns
	fake.recordInvocation("HasAPIEndpoint", []interface{}{})
	fake.hasAPIEndpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasAPIEndpointCallCount() int {
	fake.hasAPIEndpointMutex.RLock()
	defer fake.hasAPIEndpointMutex.RUnlock()
	return len(fake.hasAPIEndpointArgsForCall)
}

func (fake *FakePluginContext) HasAPIEndpointCalls(stub func() bool) {
	fake.hasAPIEndpointMutex.Lock()
	defer fake.hasAPIEndpointMutex.Unlock()
	fake.HasAPIEndpointStub = stub
}

func (fake *FakePluginContext) HasAPIEndpointReturns(result1 bool) {
	fake.hasAPIEndpointMutex.Lock()
	defer fake.hasAPIEndpointMutex.Unlock()
	fake.HasAPIEndpointStub = nil
	fake.hasAPIEndpointReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasAPIEndpointReturnsOnCall(i int, result1 bool) {
	fake.hasAPIEndpointMutex.Lock()
	defer fake.hasAPIEndpointMutex.Unlock()
	fake.HasAPIEndpointStub = nil
	if fake.hasAPIEndpointReturnsOnCall == nil {
		fake.hasAPIEndpointReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasAPIEndpointReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedAccount() bool {
	fake.hasTargetedAccountMutex.Lock()
	ret, specificReturn := fake.hasTargetedAccountReturnsOnCall[len(fake.hasTargetedAccountArgsForCall)]
	fake.hasTargetedAccountArgsForCall = append(fake.hasTargetedAccountArgsForCall, struct {
	}{})
	stub := fake.HasTargetedAccountStub
	fakeReturns := fake.hasTargetedAccountReturns
	fake.recordInvocation("HasTargetedAccount", []interface{}{})
	fake.hasTargetedAccountMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedAccountCallCount() int {
	fake.hasTargetedAccountMutex.RLock()
	defer fake.hasTargetedAccountMutex.RUnlock()
	return len(fake.hasTargetedAccountArgsForCall)
}

func (fake *FakePluginContext) HasTargetedAccountCalls(stub func() bool) {
	fake.hasTargetedAccountMutex.Lock()
	defer fake.hasTargetedAccountMutex.Unlock()
	fake.HasTargetedAccountStub = stub
}

func (fake *FakePluginContext) HasTargetedAccountReturns(result1 bool) {
	fake.hasTargetedAccountMutex.Lock()
	defer fake.hasTargetedAccountMutex.Unlock()
	fake.HasTargetedAccountStub = nil
	fake.hasTargetedAccountReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedAccountReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedAccountMutex.Lock()
	defer fake.hasTargetedAccountMutex.Unlock()
	fake.HasTargetedAccountStub = nil
	if fake.hasTargetedAccountReturnsOnCall == nil {
		fake.hasTargetedAccountReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedAccountReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCF() bool {
	fake.hasTargetedCFMutex.Lock()
	ret, specificReturn := fake.hasTargetedCFReturnsOnCall[len(fake.hasTargetedCFArgsForCall)]
	fake.hasTargetedCFArgsForCall = append(fake.hasTargetedCFArgsForCall, struct {
	}{})
	stub := fake.HasTargetedCFStub
	fakeReturns := fake.hasTargetedCFReturns
	fake.recordInvocation("HasTargetedCF", []interface{}{})
	fake.hasTargetedCFMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedCFCallCount() int {
	fake.hasTargetedCFMutex.RLock()
	defer fake.hasTargetedCFMutex.RUnlock()
	return len(fake.hasTargetedCFArgsForCall)
}

func (fake *FakePluginContext) HasTargetedCFCalls(stub func() bool) {
	fake.hasTargetedCFMutex.Lock()
	defer fake.hasTargetedCFMutex.Unlock()
	fake.HasTargetedCFStub = stub
}

func (fake *FakePluginContext) HasTargetedCFReturns(result1 bool) {
	fake.hasTargetedCFMutex.Lock()
	defer fake.hasTargetedCFMutex.Unlock()
	fake.HasTargetedCFStub = nil
	fake.hasTargetedCFReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCFReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedCFMutex.Lock()
	defer fake.hasTargetedCFMutex.Unlock()
	fake.HasTargetedCFStub = nil
	if fake.hasTargetedCFReturnsOnCall == nil {
		fake.hasTargetedCFReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedCFReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCFEE() bool {
	fake.hasTargetedCFEEMutex.Lock()
	ret, specificReturn := fake.hasTargetedCFEEReturnsOnCall[len(fake.hasTargetedCFEEArgsForCall)]
	fake.hasTargetedCFEEArgsForCall = append(fake.hasTargetedCFEEArgsForCall, struct {
	}{})
	stub := fake.HasTargetedCFEEStub
	fakeReturns := fake.hasTargetedCFEEReturns
	fake.recordInvocation("HasTargetedCFEE", []interface{}{})
	fake.hasTargetedCFEEMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedCFEECallCount() int {
	fake.hasTargetedCFEEMutex.RLock()
	defer fake.hasTargetedCFEEMutex.RUnlock()
	return len(fake.hasTargetedCFEEArgsForCall)
}

func (fake *FakePluginContext) HasTargetedCFEECalls(stub func() bool) {
	fake.hasTargetedCFEEMutex.Lock()
	defer fake.hasTargetedCFEEMutex.Unlock()
	fake.HasTargetedCFEEStub = stub
}

func (fake *FakePluginContext) HasTargetedCFEEReturns(result1 bool) {
	fake.hasTargetedCFEEMutex.Lock()
	defer fake.hasTargetedCFEEMutex.Unlock()
	fake.HasTargetedCFEEStub = nil
	fake.hasTargetedCFEEReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedCFEEReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedCFEEMutex.Lock()
	defer fake.hasTargetedCFEEMutex.Unlock()
	fake.HasTargetedCFEEStub = nil
	if fake.hasTargetedCFEEReturnsOnCall == nil {
		fake.hasTargetedCFEEReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedCFEEReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedComputeResource() bool {
	fake.hasTargetedComputeResourceMutex.Lock()
	ret, specificReturn := fake.hasTargetedComputeResourceReturnsOnCall[len(fake.hasTargetedComputeResourceArgsForCall)]
	fake.hasTargetedComputeResourceArgsForCall = append(fake.hasTargetedComputeResourceArgsForCall, struct {
	}{})
	stub := fake.HasTargetedComputeResourceStub
	fakeReturns := fake.hasTargetedComputeResourceReturns
	fake.recordInvocation("HasTargetedComputeResource", []interface{}{})
	fake.hasTargetedComputeResourceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedComputeResourceCallCount() int {
	fake.hasTargetedComputeResourceMutex.RLock()
	defer fake.hasTargetedComputeResourceMutex.RUnlock()
	return len(fake.hasTargetedComputeResourceArgsForCall)
}

func (fake *FakePluginContext) HasTargetedComputeResourceCalls(stub func() bool) {
	fake.hasTargetedComputeResourceMutex.Lock()
	defer fake.hasTargetedComputeResourceMutex.Unlock()
	fake.HasTargetedComputeResourceStub = stub
}

func (fake *FakePluginContext) HasTargetedComputeResourceReturns(result1 bool) {
	fake.hasTargetedComputeResourceMutex.Lock()
	defer fake.hasTargetedComputeResourceMutex.Unlock()
	fake.HasTargetedComputeResourceStub = nil
	fake.hasTargetedComputeResourceReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedComputeResourceReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedComputeResourceMutex.Lock()
	defer fake.hasTargetedComputeResourceMutex.Unlock()
	fake.HasTargetedComputeResourceStub = nil
	if fake.hasTargetedComputeResourceReturnsOnCall == nil {
		fake.hasTargetedComputeResourceReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedComputeResourceReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedProfile() bool {
	fake.hasTargetedProfileMutex.Lock()
	ret, specificReturn := fake.hasTargetedProfileReturnsOnCall[len(fake.hasTargetedProfileArgsForCall)]
	fake.hasTargetedProfileArgsForCall = append(fake.hasTargetedProfileArgsForCall, struct {
	}{})
	stub := fake.HasTargetedProfileStub
	fakeReturns := fake.hasTargetedProfileReturns
	fake.recordInvocation("HasTargetedProfile", []interface{}{})
	fake.hasTargetedProfileMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedProfileCallCount() int {
	fake.hasTargetedProfileMutex.RLock()
	defer fake.hasTargetedProfileMutex.RUnlock()
	return len(fake.hasTargetedProfileArgsForCall)
}

func (fake *FakePluginContext) HasTargetedProfileCalls(stub func() bool) {
	fake.hasTargetedProfileMutex.Lock()
	defer fake.hasTargetedProfileMutex.Unlock()
	fake.HasTargetedProfileStub = stub
}

func (fake *FakePluginContext) HasTargetedProfileReturns(result1 bool) {
	fake.hasTargetedProfileMutex.Lock()
	defer fake.hasTargetedProfileMutex.Unlock()
	fake.HasTargetedProfileStub = nil
	fake.hasTargetedProfileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedProfileReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedProfileMutex.Lock()
	defer fake.hasTargetedProfileMutex.Unlock()
	fake.HasTargetedProfileStub = nil
	if fake.hasTargetedProfileReturnsOnCall == nil {
		fake.hasTargetedProfileReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedProfileReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedPublicCF() bool {
	fake.hasTargetedPublicCFMutex.Lock()
	ret, specificReturn := fake.hasTargetedPublicCFReturnsOnCall[len(fake.hasTargetedPublicCFArgsForCall)]
	fake.hasTargetedPublicCFArgsForCall = append(fake.hasTargetedPublicCFArgsForCall, struct {
	}{})
	stub := fake.HasTargetedPublicCFStub
	fakeReturns := fake.hasTargetedPublicCFReturns
	fake.recordInvocation("HasTargetedPublicCF", []interface{}{})
	fake.hasTargetedPublicCFMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedPublicCFCallCount() int {
	fake.hasTargetedPublicCFMutex.RLock()
	defer fake.hasTargetedPublicCFMutex.RUnlock()
	return len(fake.hasTargetedPublicCFArgsForCall)
}

func (fake *FakePluginContext) HasTargetedPublicCFCalls(stub func() bool) {
	fake.hasTargetedPublicCFMutex.Lock()
	defer fake.hasTargetedPublicCFMutex.Unlock()
	fake.HasTargetedPublicCFStub = stub
}

func (fake *FakePluginContext) HasTargetedPublicCFReturns(result1 bool) {
	fake.hasTargetedPublicCFMutex.Lock()
	defer fake.hasTargetedPublicCFMutex.Unlock()
	fake.HasTargetedPublicCFStub = nil
	fake.hasTargetedPublicCFReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedPublicCFReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedPublicCFMutex.Lock()
	defer fake.hasTargetedPublicCFMutex.Unlock()
	fake.HasTargetedPublicCFStub = nil
	if fake.hasTargetedPublicCFReturnsOnCall == nil {
		fake.hasTargetedPublicCFReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedPublicCFReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedRegion() bool {
	fake.hasTargetedRegionMutex.Lock()
	ret, specificReturn := fake.hasTargetedRegionReturnsOnCall[len(fake.hasTargetedRegionArgsForCall)]
	fake.hasTargetedRegionArgsForCall = append(fake.hasTargetedRegionArgsForCall, struct {
	}{})
	stub := fake.HasTargetedRegionStub
	fakeReturns := fake.hasTargetedRegionReturns
	fake.recordInvocation("HasTargetedRegion", []interface{}{})
	fake.hasTargetedRegionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedRegionCallCount() int {
	fake.hasTargetedRegionMutex.RLock()
	defer fake.hasTargetedRegionMutex.RUnlock()
	return len(fake.hasTargetedRegionArgsForCall)
}

func (fake *FakePluginContext) HasTargetedRegionCalls(stub func() bool) {
	fake.hasTargetedRegionMutex.Lock()
	defer fake.hasTargetedRegionMutex.Unlock()
	fake.HasTargetedRegionStub = stub
}

func (fake *FakePluginContext) HasTargetedRegionReturns(result1 bool) {
	fake.hasTargetedRegionMutex.Lock()
	defer fake.hasTargetedRegionMutex.Unlock()
	fake.HasTargetedRegionStub = nil
	fake.hasTargetedRegionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedRegionReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedRegionMutex.Lock()
	defer fake.hasTargetedRegionMutex.Unlock()
	fake.HasTargetedRegionStub = nil
	if fake.hasTargetedRegionReturnsOnCall == nil {
		fake.hasTargetedRegionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedRegionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedResourceGroup() bool {
	fake.hasTargetedResourceGroupMutex.Lock()
	ret, specificReturn := fake.hasTargetedResourceGroupReturnsOnCall[len(fake.hasTargetedResourceGroupArgsForCall)]
	fake.hasTargetedResourceGroupArgsForCall = append(fake.hasTargetedResourceGroupArgsForCall, struct {
	}{})
	stub := fake.HasTargetedResourceGroupStub
	fakeReturns := fake.hasTargetedResourceGroupReturns
	fake.recordInvocation("HasTargetedResourceGroup", []interface{}{})
	fake.hasTargetedResourceGroupMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) HasTargetedResourceGroupCallCount() int {
	fake.hasTargetedResourceGroupMutex.RLock()
	defer fake.hasTargetedResourceGroupMutex.RUnlock()
	return len(fake.hasTargetedResourceGroupArgsForCall)
}

func (fake *FakePluginContext) HasTargetedResourceGroupCalls(stub func() bool) {
	fake.hasTargetedResourceGroupMutex.Lock()
	defer fake.hasTargetedResourceGroupMutex.Unlock()
	fake.HasTargetedResourceGroupStub = stub
}

func (fake *FakePluginContext) HasTargetedResourceGroupReturns(result1 bool) {
	fake.hasTargetedResourceGroupMutex.Lock()
	defer fake.hasTargetedResourceGroupMutex.Unlock()
	fake.HasTargetedResourceGroupStub = nil
	fake.hasTargetedResourceGroupReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) HasTargetedResourceGroupReturnsOnCall(i int, result1 bool) {
	fake.hasTargetedResourceGroupMutex.Lock()
	defer fake.hasTargetedResourceGroupMutex.Unlock()
	fake.HasTargetedResourceGroupStub = nil
	if fake.hasTargetedResourceGroupReturnsOnCall == nil {
		fake.hasTargetedResourceGroupReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hasTargetedResourceGroupReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IAMEndpoint() string {
	fake.iAMEndpointMutex.Lock()
	ret, specificReturn := fake.iAMEndpointReturnsOnCall[len(fake.iAMEndpointArgsForCall)]
	fake.iAMEndpointArgsForCall = append(fake.iAMEndpointArgsForCall, struct {
	}{})
	stub := fake.IAMEndpointStub
	fakeReturns := fake.iAMEndpointReturns
	fake.recordInvocation("IAMEndpoint", []interface{}{})
	fake.iAMEndpointMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMEndpointCallCount() int {
	fake.iAMEndpointMutex.RLock()
	defer fake.iAMEndpointMutex.RUnlock()
	return len(fake.iAMEndpointArgsForCall)
}

func (fake *FakePluginContext) IAMEndpointCalls(stub func() string) {
	fake.iAMEndpointMutex.Lock()
	defer fake.iAMEndpointMutex.Unlock()
	fake.IAMEndpointStub = stub
}

func (fake *FakePluginContext) IAMEndpointReturns(result1 string) {
	fake.iAMEndpointMutex.Lock()
	defer fake.iAMEndpointMutex.Unlock()
	fake.IAMEndpointStub = nil
	fake.iAMEndpointReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMEndpointReturnsOnCall(i int, result1 string) {
	fake.iAMEndpointMutex.Lock()
	defer fake.iAMEndpointMutex.Unlock()
	fake.IAMEndpointStub = nil
	if fake.iAMEndpointReturnsOnCall == nil {
		fake.iAMEndpointReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMEndpointReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMEndpoints() models.Endpoints {
	fake.iAMEndpointsMutex.Lock()
	ret, specificReturn := fake.iAMEndpointsReturnsOnCall[len(fake.iAMEndpointsArgsForCall)]
	fake.iAMEndpointsArgsForCall = append(fake.iAMEndpointsArgsForCall, struct {
	}{})
	stub := fake.IAMEndpointsStub
	fakeReturns := fake.iAMEndpointsReturns
	fake.recordInvocation("IAMEndpoints", []interface{}{})
	fake.iAMEndpointsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMEndpointsCallCount() int {
	fake.iAMEndpointsMutex.RLock()
	defer fake.iAMEndpointsMutex.RUnlock()
	return len(fake.iAMEndpointsArgsForCall)
}

func (fake *FakePluginContext) IAMEndpointsCalls(stub func() models.Endpoints) {
	fake.iAMEndpointsMutex.Lock()
	defer fake.iAMEndpointsMutex.Unlock()
	fake.IAMEndpointsStub = stub
}

func (fake *FakePluginContext) IAMEndpointsReturns(result1 models.Endpoints) {
	fake.iAMEndpointsMutex.Lock()
	defer fake.iAMEndpointsMutex.Unlock()
	fake.IAMEndpointsStub = nil
	fake.iAMEndpointsReturns = struct {
		result1 models.Endpoints
	}{result1}
}

func (fake *FakePluginContext) IAMEndpointsReturnsOnCall(i int, result1 models.Endpoints) {
	fake.iAMEndpointsMutex.Lock()
	defer fake.iAMEndpointsMutex.Unlock()
	fake.IAMEndpointsStub = nil
	if fake.iAMEndpointsReturnsOnCall == nil {
		fake.iAMEndpointsReturnsOnCall = make(map[int]struct {
			result1 models.Endpoints
		})
	}
	fake.iAMEndpointsReturnsOnCall[i] = struct {
		result1 models.Endpoints
	}{result1}
}

func (fake *FakePluginContext) IAMRefreshToken() string {
	fake.iAMRefreshTokenMutex.Lock()
	ret, specificReturn := fake.iAMRefreshTokenReturnsOnCall[len(fake.iAMRefreshTokenArgsForCall)]
	fake.iAMRefreshTokenArgsForCall = append(fake.iAMRefreshTokenArgsForCall, struct {
	}{})
	stub := fake.IAMRefreshTokenStub
	fakeReturns := fake.iAMRefreshTokenReturns
	fake.recordInvocation("IAMRefreshToken", []interface{}{})
	fake.iAMRefreshTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMRefreshTokenCallCount() int {
	fake.iAMRefreshTokenMutex.RLock()
	defer fake.iAMRefreshTokenMutex.RUnlock()
	return len(fake.iAMRefreshTokenArgsForCall)
}

func (fake *FakePluginContext) IAMRefreshTokenCalls(stub func() string) {
	fake.iAMRefreshTokenMutex.Lock()
	defer fake.iAMRefreshTokenMutex.Unlock()
	fake.IAMRefreshTokenStub = stub
}

func (fake *FakePluginContext) IAMRefreshTokenReturns(result1 string) {
	fake.iAMRefreshTokenMutex.Lock()
	defer fake.iAMRefreshTokenMutex.Unlock()
	fake.IAMRefreshTokenStub = nil
	fake.iAMRefreshTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMRefreshTokenReturnsOnCall(i int, result1 string) {
	fake.iAMRefreshTokenMutex.Lock()
	defer fake.iAMRefreshTokenMutex.Unlock()
	fake.IAMRefreshTokenStub = nil
	if fake.iAMRefreshTokenReturnsOnCall == nil {
		fake.iAMRefreshTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMRefreshTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMToken() string {
	fake.iAMTokenMutex.Lock()
	ret, specificReturn := fake.iAMTokenReturnsOnCall[len(fake.iAMTokenArgsForCall)]
	fake.iAMTokenArgsForCall = append(fake.iAMTokenArgsForCall, struct {
	}{})
	stub := fake.IAMTokenStub
	fakeReturns := fake.iAMTokenReturns
	fake.recordInvocation("IAMToken", []interface{}{})
	fake.iAMTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IAMTokenCallCount() int {
	fake.iAMTokenMutex.RLock()
	defer fake.iAMTokenMutex.RUnlock()
	return len(fake.iAMTokenArgsForCall)
}

func (fake *FakePluginContext) IAMTokenCalls(stub func() string) {
	fake.iAMTokenMutex.Lock()
	defer fake.iAMTokenMutex.Unlock()
	fake.IAMTokenStub = stub
}

func (fake *FakePluginContext) IAMTokenReturns(result1 string) {
	fake.iAMTokenMutex.Lock()
	defer fake.iAMTokenMutex.Unlock()
	fake.IAMTokenStub = nil
	fake.iAMTokenReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IAMTokenReturnsOnCall(i int, result1 string) {
	fake.iAMTokenMutex.Lock()
	defer fake.iAMTokenMutex.Unlock()
	fake.IAMTokenStub = nil
	if fake.iAMTokenReturnsOnCall == nil {
		fake.iAMTokenReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iAMTokenReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IMSAccountID() string {
	fake.iMSAccountIDMutex.Lock()
	ret, specificReturn := fake.iMSAccountIDReturnsOnCall[len(fake.iMSAccountIDArgsForCall)]
	fake.iMSAccountIDArgsForCall = append(fake.iMSAccountIDArgsForCall, struct {
	}{})
	stub := fake.IMSAccountIDStub
	fakeReturns := fake.iMSAccountIDReturns
	fake.recordInvocation("IMSAccountID", []interface{}{})
	fake.iMSAccountIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IMSAccountIDCallCount() int {
	fake.iMSAccountIDMutex.RLock()
	defer fake.iMSAccountIDMutex.RUnlock()
	return len(fake.iMSAccountIDArgsForCall)
}

func (fake *FakePluginContext) IMSAccountIDCalls(stub func() string) {
	fake.iMSAccountIDMutex.Lock()
	defer fake.iMSAccountIDMutex.Unlock()
	fake.IMSAccountIDStub = stub
}

func (fake *FakePluginContext) IMSAccountIDReturns(result1 string) {
	fake.iMSAccountIDMutex.Lock()
	defer fake.iMSAccountIDMutex.Unlock()
	fake.IMSAccountIDStub = nil
	fake.iMSAccountIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IMSAccountIDReturnsOnCall(i int, result1 string) {
	fake.iMSAccountIDMutex.Lock()
	defer fake.iMSAccountIDMutex.Unlock()
	fake.IMSAccountIDStub = nil
	if fake.iMSAccountIDReturnsOnCall == nil {
		fake.iMSAccountIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iMSAccountIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) IsLoggedIn() bool {
	fake.isLoggedInMutex.Lock()
	ret, specificReturn := fake.isLoggedInReturnsOnCall[len(fake.isLoggedInArgsForCall)]
	fake.isLoggedInArgsForCall = append(fake.isLoggedInArgsForCall, struct {
	}{})
	stub := fake.IsLoggedInStub
	fakeReturns := fake.isLoggedInReturns
	fake.recordInvocation("IsLoggedIn", []interface{}{})
	fake.isLoggedInMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsLoggedInCallCount() int {
	fake.isLoggedInMutex.RLock()
	defer fake.isLoggedInMutex.RUnlock()
	return len(fake.isLoggedInArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInCalls(stub func() bool) {
	fake.isLoggedInMutex.Lock()
	defer fake.isLoggedInMutex.Unlock()
	fake.IsLoggedInStub = stub
}

func (fake *FakePluginContext) IsLoggedInReturns(result1 bool) {
	fake.isLoggedInMutex.Lock()
	defer fake.isLoggedInMutex.Unlock()
	fake.IsLoggedInStub = nil
	fake.isLoggedInReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInReturnsOnCall(i int, result1 bool) {
	fake.isLoggedInMutex.Lock()
	defer fake.isLoggedInMutex.Unlock()
	fake.IsLoggedInStub = nil
	if fake.isLoggedInReturnsOnCall == nil {
		fake.isLoggedInReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInAsCRI() bool {
	fake.isLoggedInAsCRIMutex.Lock()
	ret, specificReturn := fake.isLoggedInAsCRIReturnsOnCall[len(fake.isLoggedInAsCRIArgsForCall)]
	fake.isLoggedInAsCRIArgsForCall = append(fake.isLoggedInAsCRIArgsForCall, struct {
	}{})
	stub := fake.IsLoggedInAsCRIStub
	fakeReturns := fake.isLoggedInAsCRIReturns
	fake.recordInvocation("IsLoggedInAsCRI", []interface{}{})
	fake.isLoggedInAsCRIMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsLoggedInAsCRICallCount() int {
	fake.isLoggedInAsCRIMutex.RLock()
	defer fake.isLoggedInAsCRIMutex.RUnlock()
	return len(fake.isLoggedInAsCRIArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInAsCRICalls(stub func() bool) {
	fake.isLoggedInAsCRIMutex.Lock()
	defer fake.isLoggedInAsCRIMutex.Unlock()
	fake.IsLoggedInAsCRIStub = stub
}

func (fake *FakePluginContext) IsLoggedInAsCRIReturns(result1 bool) {
	fake.isLoggedInAsCRIMutex.Lock()
	defer fake.isLoggedInAsCRIMutex.Unlock()
	fake.IsLoggedInAsCRIStub = nil
	fake.isLoggedInAsCRIReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInAsCRIReturnsOnCall(i int, result1 bool) {
	fake.isLoggedInAsCRIMutex.Lock()
	defer fake.isLoggedInAsCRIMutex.Unlock()
	fake.IsLoggedInAsCRIStub = nil
	if fake.isLoggedInAsCRIReturnsOnCall == nil {
		fake.isLoggedInAsCRIReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInAsCRIReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInAsProfile() bool {
	fake.isLoggedInAsProfileMutex.Lock()
	ret, specificReturn := fake.isLoggedInAsProfileReturnsOnCall[len(fake.isLoggedInAsProfileArgsForCall)]
	fake.isLoggedInAsProfileArgsForCall = append(fake.isLoggedInAsProfileArgsForCall, struct {
	}{})
	stub := fake.IsLoggedInAsProfileStub
	fakeReturns := fake.isLoggedInAsProfileReturns
	fake.recordInvocation("IsLoggedInAsProfile", []interface{}{})
	fake.isLoggedInAsProfileMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsLoggedInAsProfileCallCount() int {
	fake.isLoggedInAsProfileMutex.RLock()
	defer fake.isLoggedInAsProfileMutex.RUnlock()
	return len(fake.isLoggedInAsProfileArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInAsProfileCalls(stub func() bool) {
	fake.isLoggedInAsProfileMutex.Lock()
	defer fake.isLoggedInAsProfileMutex.Unlock()
	fake.IsLoggedInAsProfileStub = stub
}

func (fake *FakePluginContext) IsLoggedInAsProfileReturns(result1 bool) {
	fake.isLoggedInAsProfileMutex.Lock()
	defer fake.isLoggedInAsProfileMutex.Unlock()
	fake.IsLoggedInAsProfileStub = nil
	fake.isLoggedInAsProfileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInAsProfileReturnsOnCall(i int, result1 bool) {
	fake.isLoggedInAsProfileMutex.Lock()
	defer fake.isLoggedInAsProfileMutex.Unlock()
	fake.IsLoggedInAsProfileStub = nil
	if fake.isLoggedInAsProfileReturnsOnCall == nil {
		fake.isLoggedInAsProfileReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInAsProfileReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInWithServiceID() bool {
	fake.isLoggedInWithServiceIDMutex.Lock()
	ret, specificReturn := fake.isLoggedInWithServiceIDReturnsOnCall[len(fake.isLoggedInWithServiceIDArgsForCall)]
	fake.isLoggedInWithServiceIDArgsForCall = append(fake.isLoggedInWithServiceIDArgsForCall, struct {
	}{})
	stub := fake.IsLoggedInWithServiceIDStub
	fakeReturns := fake.isLoggedInWithServiceIDReturns
	fake.recordInvocation("IsLoggedInWithServiceID", []interface{}{})
	fake.isLoggedInWithServiceIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDCallCount() int {
	fake.isLoggedInWithServiceIDMutex.RLock()
	defer fake.isLoggedInWithServiceIDMutex.RUnlock()
	return len(fake.isLoggedInWithServiceIDArgsForCall)
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDCalls(stub func() bool) {
	fake.isLoggedInWithServiceIDMutex.Lock()
	defer fake.isLoggedInWithServiceIDMutex.Unlock()
	fake.IsLoggedInWithServiceIDStub = stub
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDReturns(result1 bool) {
	fake.isLoggedInWithServiceIDMutex.Lock()
	defer fake.isLoggedInWithServiceIDMutex.Unlock()
	fake.IsLoggedInWithServiceIDStub = nil
	fake.isLoggedInWithServiceIDReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsLoggedInWithServiceIDReturnsOnCall(i int, result1 bool) {
	fake.isLoggedInWithServiceIDMutex.Lock()
	defer fake.isLoggedInWithServiceIDMutex.Unlock()
	fake.IsLoggedInWithServiceIDStub = nil
	if fake.isLoggedInWithServiceIDReturnsOnCall == nil {
		fake.isLoggedInWithServiceIDReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isLoggedInWithServiceIDReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsPrivateEndpointEnabled() bool {
	fake.isPrivateEndpointEnabledMutex.Lock()
	ret, specificReturn := fake.isPrivateEndpointEnabledReturnsOnCall[len(fake.isPrivateEndpointEnabledArgsForCall)]
	fake.isPrivateEndpointEnabledArgsForCall = append(fake.isPrivateEndpointEnabledArgsForCall, struct {
	}{})
	stub := fake.IsPrivateEndpointEnabledStub
	fakeReturns := fake.isPrivateEndpointEnabledReturns
	fake.recordInvocation("IsPrivateEndpointEnabled", []interface{}{})
	fake.isPrivateEndpointEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsPrivateEndpointEnabledCallCount() int {
	fake.isPrivateEndpointEnabledMutex.RLock()
	defer fake.isPrivateEndpointEnabledMutex.RUnlock()
	return len(fake.isPrivateEndpointEnabledArgsForCall)
}

func (fake *FakePluginContext) IsPrivateEndpointEnabledCalls(stub func() bool) {
	fake.isPrivateEndpointEnabledMutex.Lock()
	defer fake.isPrivateEndpointEnabledMutex.Unlock()
	fake.IsPrivateEndpointEnabledStub = stub
}

func (fake *FakePluginContext) IsPrivateEndpointEnabledReturns(result1 bool) {
	fake.isPrivateEndpointEnabledMutex.Lock()
	defer fake.isPrivateEndpointEnabledMutex.Unlock()
	fake.IsPrivateEndpointEnabledStub = nil
	fake.isPrivateEndpointEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsPrivateEndpointEnabledReturnsOnCall(i int, result1 bool) {
	fake.isPrivateEndpointEnabledMutex.Lock()
	defer fake.isPrivateEndpointEnabledMutex.Unlock()
	fake.IsPrivateEndpointEnabledStub = nil
	if fake.isPrivateEndpointEnabledReturnsOnCall == nil {
		fake.isPrivateEndpointEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPrivateEndpointEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsSSLDisabled() bool {
	fake.isSSLDisabledMutex.Lock()
	ret, specificReturn := fake.isSSLDisabledReturnsOnCall[len(fake.isSSLDisabledArgsForCall)]
	fake.isSSLDisabledArgsForCall = append(fake.isSSLDisabledArgsForCall, struct {
	}{})
	stub := fake.IsSSLDisabledStub
	fakeReturns := fake.isSSLDisabledReturns
	fake.recordInvocation("IsSSLDisabled", []interface{}{})
	fake.isSSLDisabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) IsSSLDisabledCallCount() int {
	fake.isSSLDisabledMutex.RLock()
	defer fake.isSSLDisabledMutex.RUnlock()
	return len(fake.isSSLDisabledArgsForCall)
}

func (fake *FakePluginContext) IsSSLDisabledCalls(stub func() bool) {
	fake.isSSLDisabledMutex.Lock()
	defer fake.isSSLDisabledMutex.Unlock()
	fake.IsSSLDisabledStub = stub
}

func (fake *FakePluginContext) IsSSLDisabledReturns(result1 bool) {
	fake.isSSLDisabledMutex.Lock()
	defer fake.isSSLDisabledMutex.Unlock()
	fake.IsSSLDisabledStub = nil
	fake.isSSLDisabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) IsSSLDisabledReturnsOnCall(i int, result1 bool) {
	fake.isSSLDisabledMutex.Lock()
	defer fake.isSSLDisabledMutex.Unlock()
	fake.IsSSLDisabledStub = nil
	if fake.isSSLDisabledReturnsOnCall == nil {
		fake.isSSLDisabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSSLDisabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) Locale() string {
	fake.localeMutex.Lock()
	ret, specificReturn := fake.localeReturnsOnCall[len(fake.localeArgsForCall)]
	fake.localeArgsForCall = append(fake.localeArgsForCall, struct {
	}{})
	stub := fake.LocaleStub
	fakeReturns := fake.localeReturns
	fake.recordInvocation("Locale", []interface{}{})
	fake.localeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) LocaleCallCount() int {
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	return len(fake.localeArgsForCall)
}

func (fake *FakePluginContext) LocaleCalls(stub func() string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = stub
}

func (fake *FakePluginContext) LocaleReturns(result1 string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = nil
	fake.localeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) LocaleReturnsOnCall(i int, result1 string) {
	fake.localeMutex.Lock()
	defer fake.localeMutex.Unlock()
	fake.LocaleStub = nil
	if fake.localeReturnsOnCall == nil {
		fake.localeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.localeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) PluginConfig() plugin.PluginConfig {
	fake.pluginConfigMutex.Lock()
	ret, specificReturn := fake.pluginConfigReturnsOnCall[len(fake.pluginConfigArgsForCall)]
	fake.pluginConfigArgsForCall = append(fake.pluginConfigArgsForCall, struct {
	}{})
	stub := fake.PluginConfigStub
	fakeReturns := fake.pluginConfigReturns
	fake.recordInvocation("PluginConfig", []interface{}{})
	fake.pluginConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) PluginConfigCallCount() int {
	fake.pluginConfigMutex.RLock()
	defer fake.pluginConfigMutex.RUnlock()
	return len(fake.pluginConfigArgsForCall)
}

func (fake *FakePluginContext) PluginConfigCalls(stub func() plugin.PluginConfig) {
	fake.pluginConfigMutex.Lock()
	defer fake.pluginConfigMutex.Unlock()
	fake.PluginConfigStub = stub
}

func (fake *FakePluginContext) PluginConfigReturns(result1 plugin.PluginConfig) {
	fake.pluginConfigMutex.Lock()
	defer fake.pluginConfigMutex.Unlock()
	fake.PluginConfigStub = nil
	fake.pluginConfigReturns = struct {
		result1 plugin.PluginConfig
	}{result1}
}

func (fake *FakePluginContext) PluginConfigReturnsOnCall(i int, result1 plugin.PluginConfig) {
	fake.pluginConfigMutex.Lock()
	defer fake.pluginConfigMutex.Unlock()
	fake.PluginConfigStub = nil
	if fake.pluginConfigReturnsOnCall == nil {
		fake.pluginConfigReturnsOnCall = make(map[int]struct {
			result1 plugin.PluginConfig
		})
	}
	fake.pluginConfigReturnsOnCall[i] = struct {
		result1 plugin.PluginConfig
	}{result1}
}

func (fake *FakePluginContext) PluginDirectory() string {
	fake.pluginDirectoryMutex.Lock()
	ret, specificReturn := fake.pluginDirectoryReturnsOnCall[len(fake.pluginDirectoryArgsForCall)]
	fake.pluginDirectoryArgsForCall = append(fake.pluginDirectoryArgsForCall, struct {
	}{})
	stub := fake.PluginDirectoryStub
	fakeReturns := fake.pluginDirectoryReturns
	fake.recordInvocation("PluginDirectory", []interface{}{})
	fake.pluginDirectoryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) PluginDirectoryCallCount() int {
	fake.pluginDirectoryMutex.RLock()
	defer fake.pluginDirectoryMutex.RUnlock()
	return len(fake.pluginDirectoryArgsForCall)
}

func (fake *FakePluginContext) PluginDirectoryCalls(stub func() string) {
	fake.pluginDirectoryMutex.Lock()
	defer fake.pluginDirectoryMutex.Unlock()
	fake.PluginDirectoryStub = stub
}

func (fake *FakePluginContext) PluginDirectoryReturns(result1 string) {
	fake.pluginDirectoryMutex.Lock()
	defer fake.pluginDirectoryMutex.Unlock()
	fake.PluginDirectoryStub = nil
	fake.pluginDirectoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) PluginDirectoryReturnsOnCall(i int, result1 string) {
	fake.pluginDirectoryMutex.Lock()
	defer fake.pluginDirectoryMutex.Unlock()
	fake.PluginDirectoryStub = nil
	if fake.pluginDirectoryReturnsOnCall == nil {
		fake.pluginDirectoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.pluginDirectoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) RefreshIAMToken() (string, error) {
	fake.refreshIAMTokenMutex.Lock()
	ret, specificReturn := fake.refreshIAMTokenReturnsOnCall[len(fake.refreshIAMTokenArgsForCall)]
	fake.refreshIAMTokenArgsForCall = append(fake.refreshIAMTokenArgsForCall, struct {
	}{})
	stub := fake.RefreshIAMTokenStub
	fakeReturns := fake.refreshIAMTokenReturns
	fake.recordInvocation("RefreshIAMToken", []interface{}{})
	fake.refreshIAMTokenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePluginContext) RefreshIAMTokenCallCount() int {
	fake.refreshIAMTokenMutex.RLock()
	defer fake.refreshIAMTokenMutex.RUnlock()
	return len(fake.refreshIAMTokenArgsForCall)
}

func (fake *FakePluginContext) RefreshIAMTokenCalls(stub func() (string, error)) {
	fake.refreshIAMTokenMutex.Lock()
	defer fake.refreshIAMTokenMutex.Unlock()
	fake.RefreshIAMTokenStub = stub
}

func (fake *FakePluginContext) RefreshIAMTokenReturns(result1 string, result2 error) {
	fake.refreshIAMTokenMutex.Lock()
	defer fake.refreshIAMTokenMutex.Unlock()
	fake.RefreshIAMTokenStub = nil
	fake.refreshIAMTokenReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) RefreshIAMTokenReturnsOnCall(i int, result1 string, result2 error) {
	fake.refreshIAMTokenMutex.Lock()
	defer fake.refreshIAMTokenMutex.Unlock()
	fake.RefreshIAMTokenStub = nil
	if fake.refreshIAMTokenReturnsOnCall == nil {
		fake.refreshIAMTokenReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.refreshIAMTokenReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePluginContext) Trace() string {
	fake.traceMutex.Lock()
	ret, specificReturn := fake.traceReturnsOnCall[len(fake.traceArgsForCall)]
	fake.traceArgsForCall = append(fake.traceArgsForCall, struct {
	}{})
	stub := fake.TraceStub
	fakeReturns := fake.traceReturns
	fake.recordInvocation("Trace", []interface{}{})
	fake.traceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) TraceCallCount() int {
	fake.traceMutex.RLock()
	defer fake.traceMutex.RUnlock()
	return len(fake.traceArgsForCall)
}

func (fake *FakePluginContext) TraceCalls(stub func() string) {
	fake.traceMutex.Lock()
	defer fake.traceMutex.Unlock()
	fake.TraceStub = stub
}

func (fake *FakePluginContext) TraceReturns(result1 string) {
	fake.traceMutex.Lock()
	defer fake.traceMutex.Unlock()
	fake.TraceStub = nil
	fake.traceReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) TraceReturnsOnCall(i int, result1 string) {
	fake.traceMutex.Lock()
	defer fake.traceMutex.Unlock()
	fake.TraceStub = nil
	if fake.traceReturnsOnCall == nil {
		fake.traceReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.traceReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserEmail() string {
	fake.userEmailMutex.Lock()
	ret, specificReturn := fake.userEmailReturnsOnCall[len(fake.userEmailArgsForCall)]
	fake.userEmailArgsForCall = append(fake.userEmailArgsForCall, struct {
	}{})
	stub := fake.UserEmailStub
	fakeReturns := fake.userEmailReturns
	fake.recordInvocation("UserEmail", []interface{}{})
	fake.userEmailMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) UserEmailCallCount() int {
	fake.userEmailMutex.RLock()
	defer fake.userEmailMutex.RUnlock()
	return len(fake.userEmailArgsForCall)
}

func (fake *FakePluginContext) UserEmailCalls(stub func() string) {
	fake.userEmailMutex.Lock()
	defer fake.userEmailMutex.Unlock()
	fake.UserEmailStub = stub
}

func (fake *FakePluginContext) UserEmailReturns(result1 string) {
	fake.userEmailMutex.Lock()
	defer fake.userEmailMutex.Unlock()
	fake.UserEmailStub = nil
	fake.userEmailReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) UserEmailReturnsOnCall(i int, result1 string) {
	fake.userEmailMutex.Lock()
	defer fake.userEmailMutex.Unlock()
	fake.UserEmailStub = nil
	if fake.userEmailReturnsOnCall == nil {
		fake.userEmailReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.userEmailReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) VPCCRITokenURL() string {
	fake.vPCCRITokenURLMutex.Lock()
	ret, specificReturn := fake.vPCCRITokenURLReturnsOnCall[len(fake.vPCCRITokenURLArgsForCall)]
	fake.vPCCRITokenURLArgsForCall = append(fake.vPCCRITokenURLArgsForCall, struct {
	}{})
	stub := fake.VPCCRITokenURLStub
	fakeReturns := fake.vPCCRITokenURLReturns
	fake.recordInvocation("VPCCRITokenURL", []interface{}{})
	fake.vPCCRITokenURLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) VPCCRITokenURLCallCount() int {
	fake.vPCCRITokenURLMutex.RLock()
	defer fake.vPCCRITokenURLMutex.RUnlock()
	return len(fake.vPCCRITokenURLArgsForCall)
}

func (fake *FakePluginContext) VPCCRITokenURLCalls(stub func() string) {
	fake.vPCCRITokenURLMutex.Lock()
	defer fake.vPCCRITokenURLMutex.Unlock()
	fake.VPCCRITokenURLStub = stub
}

func (fake *FakePluginContext) VPCCRITokenURLReturns(result1 string) {
	fake.vPCCRITokenURLMutex.Lock()
	defer fake.vPCCRITokenURLMutex.Unlock()
	fake.VPCCRITokenURLStub = nil
	fake.vPCCRITokenURLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) VPCCRITokenURLReturnsOnCall(i int, result1 string) {
	fake.vPCCRITokenURLMutex.Lock()
	defer fake.vPCCRITokenURLMutex.Unlock()
	fake.VPCCRITokenURLStub = nil
	if fake.vPCCRITokenURLReturnsOnCall == nil {
		fake.vPCCRITokenURLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.vPCCRITokenURLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePluginContext) VersionCheckEnabled() bool {
	fake.versionCheckEnabledMutex.Lock()
	ret, specificReturn := fake.versionCheckEnabledReturnsOnCall[len(fake.versionCheckEnabledArgsForCall)]
	fake.versionCheckEnabledArgsForCall = append(fake.versionCheckEnabledArgsForCall, struct {
	}{})
	stub := fake.VersionCheckEnabledStub
	fakeReturns := fake.versionCheckEnabledReturns
	fake.recordInvocation("VersionCheckEnabled", []interface{}{})
	fake.versionCheckEnabledMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePluginContext) VersionCheckEnabledCallCount() int {
	fake.versionCheckEnabledMutex.RLock()
	defer fake.versionCheckEnabledMutex.RUnlock()
	return len(fake.versionCheckEnabledArgsForCall)
}

func (fake *FakePluginContext) VersionCheckEnabledCalls(stub func() bool) {
	fake.versionCheckEnabledMutex.Lock()
	defer fake.versionCheckEnabledMutex.Unlock()
	fake.VersionCheckEnabledStub = stub
}

func (fake *FakePluginContext) VersionCheckEnabledReturns(result1 bool) {
	fake.versionCheckEnabledMutex.Lock()
	defer fake.versionCheckEnabledMutex.Unlock()
	fake.VersionCheckEnabledStub = nil
	fake.versionCheckEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) VersionCheckEnabledReturnsOnCall(i int, result1 bool) {
	fake.versionCheckEnabledMutex.Lock()
	defer fake.versionCheckEnabledMutex.Unlock()
	fake.VersionCheckEnabledStub = nil
	if fake.versionCheckEnabledReturnsOnCall == nil {
		fake.versionCheckEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.versionCheckEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePluginContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aPIEndpointMutex.RLock()
	defer fake.aPIEndpointMutex.RUnlock()
	fake.cFMutex.RLock()
	defer fake.cFMutex.RUnlock()
	fake.cFEEEnvIDMutex.RLock()
	defer fake.cFEEEnvIDMutex.RUnlock()
	fake.cLINameMutex.RLock()
	defer fake.cLINameMutex.RUnlock()
	fake.cRITypeMutex.RLock()
	defer fake.cRITypeMutex.RUnlock()
	fake.cloudNameMutex.RLock()
	defer fake.cloudNameMutex.RUnlock()
	fake.cloudTypeMutex.RLock()
	defer fake.cloudTypeMutex.RUnlock()
	fake.colorEnabledMutex.RLock()
	defer fake.colorEnabledMutex.RUnlock()
	fake.commandNamespaceMutex.RLock()
	defer fake.commandNamespaceMutex.RUnlock()
	fake.consoleEndpointMutex.RLock()
	defer fake.consoleEndpointMutex.RUnlock()
	fake.consoleEndpointsMutex.RLock()
	defer fake.consoleEndpointsMutex.RUnlock()
	fake.currentAccountMutex.RLock()
	defer fake.currentAccountMutex.RUnlock()
	fake.currentProfileMutex.RLock()
	defer fake.currentProfileMutex.RUnlock()
	fake.currentRegionMutex.RLock()
	defer fake.currentRegionMutex.RUnlock()
	fake.currentResourceGroupMutex.RLock()
	defer fake.currentResourceGroupMutex.RUnlock()
	fake.getEndpointMutex.RLock()
	defer fake.getEndpointMutex.RUnlock()
	fake.hTTPTimeoutMutex.RLock()
	defer fake.hTTPTimeoutMutex.RUnlock()
	fake.hasAPIEndpointMutex.RLock()
	defer fake.hasAPIEndpointMutex.RUnlock()
	fake.hasTargetedAccountMutex.RLock()
	defer fake.hasTargetedAccountMutex.RUnlock()
	fake.hasTargetedCFMutex.RLock()
	defer fake.hasTargetedCFMutex.RUnlock()
	fake.hasTargetedCFEEMutex.RLock()
	defer fake.hasTargetedCFEEMutex.RUnlock()
	fake.hasTargetedComputeResourceMutex.RLock()
	defer fake.hasTargetedComputeResourceMutex.RUnlock()
	fake.hasTargetedProfileMutex.RLock()
	defer fake.hasTargetedProfileMutex.RUnlock()
	fake.hasTargetedPublicCFMutex.RLock()
	defer fake.hasTargetedPublicCFMutex.RUnlock()
	fake.hasTargetedRegionMutex.RLock()
	defer fake.hasTargetedRegionMutex.RUnlock()
	fake.hasTargetedResourceGroupMutex.RLock()
	defer fake.hasTargetedResourceGroupMutex.RUnlock()
	fake.iAMEndpointMutex.RLock()
	defer fake.iAMEndpointMutex.RUnlock()
	fake.iAMEndpointsMutex.RLock()
	defer fake.iAMEndpointsMutex.RUnlock()
	fake.iAMRefreshTokenMutex.RLock()
	defer fake.iAMRefreshTokenMutex.RUnlock()
	fake.iAMTokenMutex.RLock()
	defer fake.iAMTokenMutex.RUnlock()
	fake.iMSAccountIDMutex.RLock()
	defer fake.iMSAccountIDMutex.RUnlock()
	fake.isLoggedInMutex.RLock()
	defer fake.isLoggedInMutex.RUnlock()
	fake.isLoggedInAsCRIMutex.RLock()
	defer fake.isLoggedInAsCRIMutex.RUnlock()
	fake.isLoggedInAsProfileMutex.RLock()
	defer fake.isLoggedInAsProfileMutex.RUnlock()
	fake.isLoggedInWithServiceIDMutex.RLock()
	defer fake.isLoggedInWithServiceIDMutex.RUnlock()
	fake.isPrivateEndpointEnabledMutex.RLock()
	defer fake.isPrivateEndpointEnabledMutex.RUnlock()
	fake.isSSLDisabledMutex.RLock()
	defer fake.isSSLDisabledMutex.RUnlock()
	fake.localeMutex.RLock()
	defer fake.localeMutex.RUnlock()
	fake.pluginConfigMutex.RLock()
	defer fake.pluginConfigMutex.RUnlock()
	fake.pluginDirectoryMutex.RLock()
	defer fake.pluginDirectoryMutex.RUnlock()
	fake.refreshIAMTokenMutex.RLock()
	defer fake.refreshIAMTokenMutex.RUnlock()
	fake.traceMutex.RLock()
	defer fake.traceMutex.RUnlock()
	fake.userEmailMutex.RLock()
	defer fake.userEmailMutex.RUnlock()
	fake.vPCCRITokenURLMutex.RLock()
	defer fake.vPCCRITokenURLMutex.RUnlock()
	fake.versionCheckEnabledMutex.RLock()
	defer fake.versionCheckEnabledMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePluginContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ plugin.PluginContext = new(FakePluginContext)
